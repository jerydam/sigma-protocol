"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5250],{94968:(e,t,n)=>{let r,a,i,s,o,l,c,d,u;n.d(t,{A:()=>tW,B:()=>tY,C:()=>eW,D:()=>X,E:()=>ee,F:()=>tT,G:()=>tJ,H:()=>Z,I:()=>nl,P:()=>e9,R:()=>eu,S:()=>eE,W:()=>e7,a:()=>ex,b:()=>eT,c:()=>tE,d:()=>nd,e:()=>tt,f:()=>ts,g:()=>ta,h:()=>tr,i:()=>to,j:()=>ti,k:()=>tj,l:()=>eC,m:()=>eN,n:()=>tn,o:()=>ef,p:()=>tN,q:()=>ev,r:()=>eA,s:()=>tD,t:()=>tO,u:()=>nc,v:()=>tq,w:()=>tk,x:()=>tU,y:()=>tI,z:()=>ea});var h=n(73788),p=n(65936),w=n(5540),m=n(23667),y=n(45852),g=n(16350),f=n(87890),v=n(71860),A=n(79312),b=n(7764),C=n(41196),_=n(97365),k=n(86249),T=n(69375),E=n(87386),S=n(79265),I=n(75187),P=n(44748),W=n(28349),U=n(16678),x=n(98539),O=n(84968),N=n(33668),R=n(5974),M=n(88836),F=n(22353),D=n(78912),L=n(31189),j=n(96578),z=n(94156),q=n(39601),H=n(14339),B=n(83266),V=n(53763),K=n(71361),$=n(36983),G=n(26027),Y=n(32709);n(57668);class J{static parse(e){try{return new J(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return f.i(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=f.i(e)}}class Q extends J{static parse(e){try{return new Q(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}let Z=({style:e,...t})=>(0,h.jsxs)("svg",{viewBox:"0 0 1024 1024",fill:"none",xmlns:"http://www.w3.org/2000/svg",style:{height:"28px",width:"28px",...e},...t,children:[(0,h.jsx)("rect",{width:"1024",height:"1024",fill:"#0052FF",rx:100,ry:100}),(0,h.jsx)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",fill:"white"})]}),X="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",ee="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";class et extends C.E{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:ee,id:"com.coinbase.wallet"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new k.P("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw(0,T.f)(e)}}constructor(e,t,a,i,s){super("base_account",e,t,a),this.connectorType="base_account",this.walletClientType="base_account",this.displayName="Base",this.setBaseAccountSdk=s,this.proxyProvider=new C.P(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...i,appChainIds:[t.id].concat(e.map(e=>e.id))},r?(this.proxyProvider.setWalletProvider(r.getProvider()),this.setBaseAccountSdk(r)):this.importPromise=n.e(4191).then(n.bind(n,4191)).then(({createBaseAccountSDK:e})=>{r=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(r.getProvider()),this.setBaseAccountSdk(r)}).catch(console.error)}}let en=[1,0xaa36a7,137,10,8453,84532,42161,7777777,43114,56];class er extends C.E{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:X,id:"com.coinbase.wallet"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new k.P("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw(0,T.f)(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType="smartWalletOnly"===e?"coinbase_smart_wallet":"coinbase_wallet",a=(0,E._)({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider(a.getProvider())}constructor(e,t,n,r){if(super("coinbase_wallet",e,t,n),this.connectorType="coinbase_wallet",this.displayName="Coinbase Wallet",this.proxyProvider=new C.P(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...r,appChainIds:[t.id].concat(e.map(e=>e.id))},this.walletClientType="smartWalletOnly"===this.coinbaseWalletConfig.preference?.options?"coinbase_smart_wallet":"coinbase_wallet","coinbase_smart_wallet"===this.walletClientType&&(this.displayName="Coinbase Smart Wallet"),!a){let e="eoaOnly"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter(e=>!en.includes(e)):[];e.length>0&&!e.every(e=>w.o.has(e))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(", ")}`),a=(0,E._)(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider(a.getProvider())}}let ea=({...e})=>(0,h.jsx)("svg",{width:"15",height:"15",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg",...e,children:(0,h.jsx)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",fill:e.color||"var(--privy-color-foreground-3)"})});class ei extends C.E{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[(0,C.t)(e?.chainId||"0x1")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:"Privy Wallet",icon:ea,id:"io.privy.wallet"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:n,rpcConfig:r,imported:a,walletIndex:i}){super("privy",t,n,r),this.connectorType="embedded",this.proxyProvider=e,this.walletIndex=i,a&&(this.connectorType="embedded_imported"),this.subscribeListeners()}}async function es(){let e=no();return e?e.getAccessToken():Promise.resolve(T.s.get(I.P)||T.s.get(I.C)||null)}let eo=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];function el(e){return e?{"privy-ui":"t"}:void 0}class ec{async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new k.a("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(R.p,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new k.a("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(R.a,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw(0,k.f)(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new k.a("Auth flow has no API instance");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new k.a("Email must be set when initialzing authentication.");let r=el(n);try{return await this.api.post(R.b,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw(0,k.f)(e)}}constructor({email:e,captchaToken:t,disableSignup:n}){this.meta={email:e,captchaToken:t,disableSignup:n??!1}}}class ed extends ec{async link(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new k.a("Email, email code, and an old email address must be set prior to calling update.");try{return await this.api.post(R.u,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw(0,k.f)(e)}}constructor(e,t,n){super({email:t,captchaToken:n}),this.meta={email:t,captchaToken:n,oldAddress:e,disableSignup:!1}}}class eu{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class eh{get meta(){return this._meta}async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.channelToken)throw new k.a("Auth flow must be initialized first");try{let e=await this.api.post(R.f,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});if(!e)throw new k.a("No response from authentication");return e}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.c,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw(0,k.f)(e)}}async _startChannelOnce(){if(!this.api)throw new k.a("Auth flow has no API instance");let e=await this.api.post(R.d,{token:this.captchaToken});W.Fr&&!W.un&&e.connect_uri&&(0,M.o)(e.connect_uri,"_blank"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new k.a("Auth flow has no API instance");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.channelToken)throw new k.a("Auth flow must be initialized first");let e=await this.api.get(R.e,{headers:{"farcaster-channel-token":this.meta.channelToken}});return"completed"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new eu(this._startChannelOnce.bind(this)),this.pollForReady=new eu(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function ep(){return"undefined"!=typeof window&&"chrome-extension:"===window.location.protocol&&"chrome"in window}function ew(){if(!ep())return;let e=window.chrome;return e?.runtime?.id}function em(){if(!ep())return!1;let e=window.chrome;return"function"==typeof e?.identity?.launchWebAuthFlow}async function ey(e){return new Promise((t,n)=>{em()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},async e=>{try{let n=function(){if(!ep())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(n||!e){let e=`WebAuthFlow failed: ${n||"Response URI missing"}`;throw Error(e)}let r=new URL(e),a=ew();if(!a)throw Error("Invalid extension context");if("chrome-extension:"===r.protocol){if(r.hostname!==a)throw Error("Invalid responseUri origin")}else{if("https:"!==r.protocol)throw Error("Invalid responseUri protocol");{let e=r.hostname.split(".");if(3!==e.length||"chromiumapp"!==e[1]||"org"!==e[2]||e[0]!==a)throw Error("Invalid responseUri origin")}}let i=r.searchParams.get("privy_oauth_state"),s=r.searchParams.get("privy_oauth_code");if(!i||!s)throw Error("Invalid responseUri - missing required parameters");t({privyOAuthState:i,privyOAuthCode:s})}catch(e){n(e)}}):n(Error("Chrome identity API not available"))})}function eg(e){return crypto.getRandomValues(new Uint8Array(e))}function ef(){return v.l(eg(36))}function ev(){return ef()}async function eA(e,t="S256"){if("S256"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest("SHA-256",t))}(e);return v.l(t)}}class eb{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new k.a("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");if("undefined"===this.meta.authorizationCode)throw new k.a("User denied confirmation during OAuth flow");let e=function(){let e=T.s.get(I.a);if(!e)throw new k.a("Authentication error.");return e}();try{let t=await this.api.post(R.o,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});return T.s.del(I.a),T.s.del(I.H),T.s.del(I.O),t}catch(t){let e=(0,k.f)(t);if(e.privyErrorCode)throw new k.a(e.message||"Invalid code during OAuth flow.",void 0,e.privyErrorCode);if("User denied confirmation during OAuth flow"===e.message)throw new k.a("Invalid code during oauth flow.",void 0,k.b.OAUTH_USER_DENIED);throw new k.a("Invalid code during OAuth flow.",void 0,k.b.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new k.a("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");if("undefined"===this.meta.authorizationCode)throw new k.a("User denied confirmation during OAuth flow");let e=T.s.get(I.a);if(!e)throw new k.a("Authentication error.");try{let t=await this.api.post(R.g,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return T.s.del(I.a),t}catch(e){throw(0,k.f)(e)}}async getAuthorizationUrl(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.provider)throw new k.a("Provider must be set when initializing OAuth authentication.");let e=ef();T.s.put(I.a,e);let t=ev();T.s.put(I.S,t);let n=await eA(e);this.meta.withPrivyUi||T.s.put(I.H,!0),this.meta.disableSignup?T.s.put(I.O,!0):T.s.del(I.O);let r=el(this.meta.withPrivyUi),a=window.location.href,i=function(){let e=ew();if(e)return`https://${e}.chromiumapp.org`}();i&&(a=i);try{return await this.api.post(R.h,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||a,token:this.meta.captchaToken,code_challenge:n,state_code:t},{headers:{...r}})}catch(e){throw(0,k.f)(e)}}constructor(e){this.meta=e}}function eC(){let e=new URL(window.location.href);e.searchParams.delete("privy_oauth_code"),e.searchParams.delete("privy_oauth_provider"),e.searchParams.delete("privy_oauth_state"),T.s.del(I.S),window.history.replaceState({},"",e)}class e_{async initRegisterFlow(e){if(!this.api)throw new k.a("Auth flow has no API instance");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new k.a("Auth flow has no API instance");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new k.a("Auth flow has no API instance");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await n.e(4665).then(n.bind(n,54665));if(!this.api)throw new k.a("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new k.a("WebAuthn is not supported in this browser");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(R.i,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new k.a("Passkey request timed out or rejected by user.",void 0,k.b.PASSKEY_NOT_ALLOWED);throw(0,k.f)(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await n.e(4665).then(n.bind(n,54665));if(!this.api)throw new k.a("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new k.a("WebAuthn is not supported in this browser");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map(e=>({type:"public-key",id:e}))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let n=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(R.j,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new k.a("Passkey request timed out or rejected by user.",void 0,k.b.PASSKEY_NOT_ALLOWED);throw(0,k.f)(e)}}async link(){let e=await n.e(4665).then(n.bind(n,54665));if(!this.api)throw new k.a("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new k.a("WebAuthn is not supported in this browser");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(R.k,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new k.a("Passkey request timed out or rejected by user.",void 0,k.b.PASSKEY_NOT_ALLOWED);throw(0,k.f)(e)}}async _initRegisterOnce(e){if(!this.api)throw new k.a("Auth flow has no API instance");let t=el(e);return await this.api.post(R.l,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new k.a("Auth flow has no API instance");let t=el(e);return await this.api.post(R.m,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new k.a("Auth flow has no API instance");return await this.api.post(R.n,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map(e=>({type:e.type,alg:e.alg})),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map(e=>({id:e.id,type:e.type,transports:e.transports})),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map(e=>({id:e.id,type:e.type,transports:e.transports}))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:n}){this.authenticateForRegistration=!1,this.initRegisterOnce=new eu(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new eu(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new eu(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:n}}}let ek=({address:e,chainId:t,nonce:n})=>`${window.location.host} wants you to sign in with your Ethereum account:
${e}

By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.

URI: ${window.location.origin}
Version: 1
Chain ID: ${t}
Nonce: ${n}
Issued At: ${(new Date).toISOString()}
Resources:
- https://privy.io`;class eT{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new k.a("SiweFlow has no client instance");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?"no-signup":"login-or-sign-up"});if(!this.wallet)throw new k.a("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.client)throw new k.a("SiweFlow has no client instance");try{if(!this.wallet)throw new k.a("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw(0,k.f)(e)}}async sign(){if(!this.client)throw new k.a("SiweFlow has no client instance");if(await this.buildMessage(),!this.preparedMessage)throw new k.a("Could not prepare SIWE message");if(!this.wallet)throw new k.a("SiweFlow has no wallet instance");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new k.a("SiweFlow has no client instance");if(!this.wallet)throw new k.a("UI SiweFlow has no wallet instance");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new k.a("SiweFlow has no client instance");if(!this.wallet)throw new k.a("SiweFlow has no wallet instance");let e=this.wallet.address,t=this.wallet.chainId.replace("eip155:","");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=ek({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a){this._meta={disableSignup:!1},this.getNonceOnce=new eu(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=n,this.client=e,this._meta.disableSignup=r,this.preparedMessage=a?.message,this.signature=a?.signature,this.walletClientType=a?.walletClientType,this.connectorType=a?.connectorType}}class eE{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new k.a("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up",messageType:this.meta.messageType})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.client)throw new k.a("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw(0,k.f)(e)}}async sign(){let e,t;if(!this.client)throw new k.a("SiwsFlow has no client instance");await this.buildMessage();let n="transaction"===this.meta.messageType;if(!this.preparedMessage)throw new k.a("Could not prepare SIWS message");if(!n&&!this.wallet.provider.signMessage||n&&!this.wallet.provider.signTransaction)throw new k.a("Wallet does not support the necessary signing methods");if(n&&this._plugin){let n=await this.wallet.provider.signTransaction({transaction:F.K3.decode(this.preparedMessage)});e=F.K3.encode(n.signedTransaction),t=this._plugin.getSignatureFromTransaction(n.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let n=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=F.K3.encode(n.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new k.a("SiwsFlow has no client instance");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new k.a("SiwsFlow has no client instance");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),"transaction"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=(0,M.p)({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a="plain",i){this._meta={disableSignup:!1,messageType:"plain"},this.getNonceOnce=new eu(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=n,this.client=t,this._meta.disableSignup=r,this._meta.messageType=a,this._plugin=i}}class eS{async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new k.a("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(R.q,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new k.a("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(R.r,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw(0,k.f)(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new k.a("Auth flow has no API instance");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new k.a("phone nNumber must be set when initialzing authentication.");let r=el(n);try{return await this.api.post(R.s,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw(0,k.f)(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:n}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:n??!1}}}class eI extends eS{async link(){if(!this.api)throw new k.a("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new k.a("Phone number, sms code, and an old phone number must be set prior to calling update.");try{return await this.api.post(R.t,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw(0,k.f)(e)}}constructor(e,t,n){super({phoneNumber:t,captchaToken:n}),this.meta={phoneNumber:t,captchaToken:n,oldPhoneNumber:e,disableSignup:!1}}}let eP=(0,p.createContext)({enabled:!1,siteKey:"",provider:void 0,appId:void 0,token:void 0,error:void 0,status:"disabled",setToken:k.n,setError:k.n,setExecuting:k.n,waitForResult:()=>Promise.resolve(""),ref:{current:null},remove:k.d,reset:k.n,execute:k.n});class eW extends k.c{constructor(e,t,n){super(e||"Captcha failed"),this.type="Captcha",t instanceof Error&&(this.cause=t),this.privyErrorCode=n}}let eU=({children:e,appId:t,captchaSiteKey:n,enabledCaptchaProvider:r})=>{let a=(0,p.useRef)(null),i=(0,p.useRef)(null),[s,o]=(0,p.useState)(),[l,c]=(0,p.useState)(),[d,u]=(0,p.useState)(!1),w=(0,p.useMemo)(()=>r?d||s||l?!d||s||l?s&&!l?{status:"success",token:s}:l?{status:"error",error:l}:{status:"ready"}:{status:"loading"}:{status:"ready"}:{status:"disabled"},[r,s,l,d]),m=(0,p.useMemo)(()=>r?"turnstile"===r?{remove:()=>{a.current?.remove(),u(!1),c(void 0),o(void 0)},reset:()=>{a.current?.reset(),u(!1),c(void 0),o(void 0)},execute:()=>{u(!0),a.current?.execute()},waitForResult:async()=>{try{return await (0,C.p)(()=>a.current?.getResponse(),{interval:200,timeout:2e4})}catch(e){throw new eW("Captcha failed",null,k.b.CAPTCHA_TIMEOUT)}}}:{remove:()=>{i.current?.removeCaptcha(),u(!1),c(void 0),o(void 0)},reset:()=>{i.current?.resetCaptcha(),u(!1),c(void 0),o(void 0)},execute:()=>{u(!0),i.current?.execute()},waitForResult:async()=>{try{return await (0,C.p)(()=>{let e=i.current?.getResponse();if(e)return e},{interval:200,timeout:2e4})}catch(e){throw new eW("Captcha failed",null,k.b.CAPTCHA_TIMEOUT)}}}:null,[r]),y=(0,p.useMemo)(()=>{if(!r||!m)return{...w,enabled:!1,siteKey:"",appId:t,setToken:k.n,setError:k.n,setExecuting:k.n,waitForResult:()=>Promise.resolve(void 0),remove:k.d,reset:k.n,execute:k.n,provider:void 0,ref:{current:null}};let e={...w,enabled:!0,appId:t,setToken:o,setError:c,setExecuting:u};return"turnstile"===r?{...e,provider:"turnstile",ref:a,siteKey:n.split("t:")[1]??"",...m}:{...e,provider:"hcaptcha",ref:i,siteKey:n.split("h:")[1]??"",...m}},[w,r,m,t,n]);return(0,h.jsx)(eP.Provider,{value:y,children:e})},ex=()=>(0,p.useContext)(eP);class eO{async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.v,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.w,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw(0,k.f)(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function eN(e){let t={detail:"",retryable:!1};return e?.privyErrorCode===k.b.LINKED_TO_ANOTHER_USER&&(t.detail="This account has already been linked to another user."),e?.privyErrorCode===k.b.DISALLOWED_LOGIN_METHOD&&(t.detail="Login with Telegram not allowed."),e?.privyErrorCode===k.b.INVALID_DATA&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===k.b.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===k.b.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===k.b.TOO_MANY_REQUESTS&&(t.detail="Too many requests. Please wait before trying again."),e?.privyErrorCode===k.b.TOO_MANY_REQUESTS&&e.message.includes("rate limit")&&(t.detail="Request limit reached for Telegram. Please wait a moment and try again."),e instanceof eW&&(t.retryable=!0,t.detail="Something went wrong. Try again."),t}function eR(e){return Object.fromEntries(decodeURIComponent(e).split("&").map(e=>e.split("=").map(decodeURIComponent)))}function eM(){let e=new URL(window.location.href);e.searchParams.delete("id"),e.searchParams.delete("hash"),e.searchParams.delete("auth_date"),e.searchParams.delete("first_name"),e.searchParams.delete("last_name"),e.searchParams.delete("username"),e.searchParams.delete("photo_url"),e.hash="",window.history.replaceState({},"",e)}let eF=(0,p.lazy)(()=>n.e(5696).then(n.bind(n,35696))),eD=(0,p.lazy)(()=>n.e(3516).then(n.bind(n,91135))),eL=e=>{let t=ex();return(0,p.useEffect)(()=>t.remove,[t.remove]),t.enabled&&t.provider?(0,h.jsx)(p.Suspense,{fallback:null,children:(0,h.jsxs)("div",{className:"hidden h-0 w-0",children:["turnstile"===t.provider&&(0,h.jsx)(eF,{...e,captchaContext:t}),"hcaptcha"===t.provider&&(0,h.jsx)(eD,{...e,captchaContext:t})]})}):null};var ej=Object.freeze({__proto__:null,AccountNotFoundScreen:()=>Promise.all([n.e(4124),n.e(7136)]).then(n.bind(n,7136)),AffirmativeConsentScreen:()=>Promise.all([n.e(4124),n.e(5629)]).then(n.bind(n,35629)),AllowlistRejectionScreen:()=>Promise.all([n.e(4124),n.e(58)]).then(n.bind(n,80058)),AuthenticateWithWalletScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(249),n.e(8596)]).then(n.bind(n,88596)),AwaitingEvmToSolBridgingScreen:()=>Promise.all([n.e(540),n.e(4124),n.e(4733),n.e(8473),n.e(4579),n.e(9276)]).then(n.bind(n,39276)),AwaitingExternalEthereumTransferScreen:()=>Promise.all([n.e(540),n.e(4124),n.e(4733),n.e(8473),n.e(4579),n.e(3666)]).then(n.bind(n,93666)),AwaitingPasswordlessCodeScreen:()=>Promise.all([n.e(4124),n.e(2942)]).then(n.bind(n,12942)),AwaitingSolToEvmBridgingScreen:()=>Promise.all([n.e(4124),n.e(8473),n.e(7530)]).then(n.bind(n,29945)),CaptchaScreen:()=>Promise.all([n.e(4124),n.e(5823)]).then(n.bind(n,85823)),CoinbaseOnrampStatusScreen:()=>Promise.all([n.e(4124),n.e(9621)]).then(n.bind(n,69621)),ConnectLedgerScreen:()=>Promise.all([n.e(4124),n.e(6167)]).then(n.bind(n,56167)),ConnectOnlyLandingScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(249),n.e(3996)]).then(n.bind(n,13996)),ConnectOnlyStatusScreen:()=>Promise.all([n.e(4124),n.e(8263)]).then(n.bind(n,8263)),ConnectOrCreateScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(2685),n.e(249),n.e(5927),n.e(9187),n.e(7322)]).then(n.bind(n,47322)),ConnectionStatusScreen:()=>Promise.all([n.e(4124),n.e(2051)]).then(n.bind(n,12051)),CrossAppAuthScreen:()=>Promise.all([n.e(4124),n.e(4517)]).then(n.bind(n,54517)),DelegatedActionsConsentScreen:()=>Promise.all([n.e(4124),n.e(5548)]).then(n.bind(n,85548)),DelegatedActionsRevokeScreen:()=>Promise.all([n.e(4124),n.e(5828)]).then(n.bind(n,75828)),EmbeddedWalletConnectingScreen:()=>Promise.all([n.e(4124),n.e(8010)]).then(n.bind(n,48010)),EmbeddedWalletCreatedScreen:()=>Promise.all([n.e(4124),n.e(8059)]).then(n.bind(n,48059)),EmbeddedWalletKeyExportScreen:()=>Promise.all([n.e(4124),n.e(7318)]).then(n.bind(n,47318)),EmbeddedWalletOnAccountCreateScreen:()=>Promise.all([n.e(4124),n.e(5506)]).then(n.bind(n,25506)),EmbeddedWalletPasswordCreateScreen:()=>Promise.all([n.e(4124),n.e(1273),n.e(4884)]).then(n.bind(n,74884)),EmbeddedWalletPasswordUpdateScreen:()=>Promise.all([n.e(4124),n.e(1273),n.e(617)]).then(n.bind(n,20617)),EmbeddedWalletPasswordUpdateSplashScreen:()=>Promise.all([n.e(4124),n.e(5429)]).then(n.bind(n,5429)),ErrorScreen:()=>Promise.all([n.e(4124),n.e(8355)]).then(n.bind(n,98355)),FarcasterConnectStatusScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(8627)]).then(n.bind(n,18627)),FarcasterSignerStatusScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(4810)]).then(n.bind(n,74810)),FundSolWalletWithExternalSolanaWallet:()=>Promise.all([n.e(4124),n.e(4813)]).then(n.bind(n,44813)),FundingAmountEditScreen:()=>Promise.all([n.e(4124),n.e(4733),n.e(614)]).then(n.bind(n,70614)),FundingMethodSelectionScreen:()=>Promise.all([n.e(4124),n.e(4733),n.e(7564)]).then(n.bind(n,47564)),InAppBrowserLoginNotPossible:()=>Promise.all([n.e(4124),n.e(1625)]).then(n.bind(n,61625)),InstallWalletScreen:()=>Promise.all([n.e(4124),n.e(9529)]).then(n.bind(n,39529)),LandingScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(2685),n.e(249),n.e(5927),n.e(9187),n.e(5718)]).then(n.bind(n,35718)),LinkConflictScreen:()=>Promise.all([n.e(4124),n.e(1682)]).then(n.bind(n,21682)),LinkEmailScreen:()=>Promise.all([n.e(4124),n.e(501)]).then(n.bind(n,501)),LinkPasskeyScreen:()=>Promise.all([n.e(4124),n.e(4733)]).then(n.bind(n,64733)),LinkPhoneScreen:()=>Promise.all([n.e(4124),n.e(2685),n.e(7466)]).then(n.bind(n,67466)),LoginFailedScreen:()=>Promise.all([n.e(4124),n.e(5561)]).then(n.bind(n,95561)),ManualTransferScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(1673)]).then(n.bind(n,71673)),MfaAuthEnrollmentFlowScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(4733),n.e(8216),n.e(2075)]).then(n.bind(n,73597)),MfaAuthVerifyFlowScreen:()=>Promise.all([n.e(4124),n.e(1919),n.e(7170),n.e(1514)]).then(n.bind(n,11514)),MfaEnrollmentFlowScreen:()=>Promise.all([n.e(4124),n.e(7635),n.e(4733),n.e(2685),n.e(8216),n.e(4769)]).then(n.bind(n,44769)),MoonpayStatusScreen:()=>Promise.all([n.e(4124),n.e(7874)]).then(n.bind(n,47874)),OAuthStatusScreen:()=>Promise.all([n.e(4124),n.e(5927),n.e(8200)]).then(n.bind(n,23566)),PasskeySelectSignupOrLogin:()=>Promise.all([n.e(4124),n.e(9093)]).then(n.bind(n,59093)),PasskeyStatusScreen:()=>Promise.all([n.e(4124),n.e(4578)]).then(n.bind(n,34578)),PasswordRecoveryScreen:()=>Promise.all([n.e(4124),n.e(2824)]).then(n.bind(n,32824)),RecoveryOAuthScreen:()=>Promise.all([n.e(4124),n.e(4383)]).then(n.bind(n,4383)),RecoverySelectionScreen:()=>Promise.all([n.e(4124),n.e(7321)]).then(n.bind(n,97321)),SendTransactionScreen:()=>Promise.all([n.e(4124),n.e(1919),n.e(3336),n.e(8395)]).then(n.bind(n,78395)),SetAutomaticRecoveryScreen:()=>Promise.all([n.e(4124),n.e(2578)]).then(n.bind(n,62578)),SignRequestScreen:()=>Promise.all([n.e(4124),n.e(4332)]).then(n.bind(n,34332)),StandardSignAndSendTransactionScreen:()=>Promise.all([n.e(4124),n.e(3336),n.e(4689)]).then(n.bind(n,20024)),TelegramAuthScreen:()=>Promise.all([n.e(4124),n.e(8653)]).then(n.bind(n,48653)),TransferFromWalletScreen:()=>Promise.all([n.e(4124),n.e(4733),n.e(3546)]).then(n.bind(n,43546)),UpdateEmailScreen:()=>Promise.all([n.e(4124),n.e(4782)]).then(n.bind(n,54782)),UpdatePhoneScreen:()=>Promise.all([n.e(4124),n.e(2685),n.e(7283)]).then(n.bind(n,87283)),UserLimitReachedScreen:()=>Promise.all([n.e(4124),n.e(271)]).then(n.bind(n,50271)),WalletInterstitialScreen:()=>Promise.all([n.e(4124),n.e(3741)]).then(n.bind(n,63741))});let ez=(0,j.v)(()=>({inProgressMfaFlow:void 0})),eq=(0,D.DU)`
  :root {
     ${e=>eH(e.palette)}
  };
`,eH=e=>{let t={"--privy-color-background":e.background,"--privy-color-background-2":e.background2,"--privy-color-background-3":e.background3,"--privy-color-foreground":e.foreground,"--privy-color-foreground-2":e.foreground2,"--privy-color-foreground-3":e.foreground3,"--privy-color-foreground-4":e.foreground4,"--privy-color-foreground-accent":e.foregroundAccent,"--privy-color-accent":e.accent,"--privy-color-accent-light":e.accentLight,"--privy-color-accent-hover":e.accentHover,"--privy-color-accent-dark":e.accentDark,"--privy-color-accent-darkest":e.accentDarkest,"--privy-color-success":e.success,"--privy-color-success-dark":e.successDark,"--privy-color-success-light":e.successLight,"--privy-color-success-bg":e.successBg,"--privy-color-error":e.error,"--privy-color-error-light":e.errorLight,"--privy-color-error-bg":e.errorBg,"--privy-color-error-bg-hover":e.errorBgHover,"--privy-color-warn":e.warn,"--privy-color-warn-light":e.warnLight,"--privy-color-warn-bg":e.warnBg,"--privy-color-warning-dark":e.warningDark,"--privy-color-error-dark":e.errorDark,"--privy-color-info-bg":e.infoBg,"--privy-color-info-bg-hover":e.infoBgHover,"--privy-color-border-default":e.borderDefault,"--privy-color-border-hover":e.borderHover,"--privy-color-border-focus":e.borderFocus,"--privy-color-border-error":e.borderError,"--privy-color-border-success":e.borderSuccess,"--privy-color-border-warning":e.borderWarning,"--privy-color-border-info":e.borderInfo,"--privy-color-border-interactive":e.borderInteractive,"--privy-color-border-interactive-hover":e.borderInteractiveHover,"--privy-color-background-hover":e.backgroundHover,"--privy-color-background-clicked":e.backgroundClicked,"--privy-color-background-disabled":e.backgroundDisabled,"--privy-color-background-interactive":e.backgroundInteractive,"--privy-color-background-interactive-hover":e.backgroundInteractiveHover,"--privy-color-background-interactive-clicked":e.backgroundInteractiveClicked,"--privy-color-background-interactive-disabled":e.backgroundInteractiveDisabled,"--privy-color-foreground-hover":e.foregroundHover,"--privy-color-foreground-clicked":e.foregroundClicked,"--privy-color-foreground-disabled":e.foregroundDisabled,"--privy-color-foreground-interactive":e.foregroundInteractive,"--privy-color-foreground-interactive-hover":e.foregroundInteractiveHover,"--privy-link-navigation-color":e.linkNavigationColor,"--privy-link-navigation-decoration":e.linkNavigationDecoration,"--privy-accent-has-good-contrast":e.accentHasGoodContrast,"--privy-color-icon-default":e.iconDefault,"--privy-color-icon-muted":e.iconMuted,"--privy-color-icon-subtle":e.iconSubtle,"--privy-color-icon-inverse":e.iconInverse,"--privy-color-icon-success":e.iconSuccess,"--privy-color-icon-warning":e.iconWarning,"--privy-color-icon-error":e.iconError,"--privy-color-icon-interactive":e.iconInteractive,"--privy-color-icon-default-hover":e.iconDefaultHover,"--privy-color-icon-muted-hover":e.iconMutedHover,"--privy-color-icon-subtle-hover":e.iconSubtleHover,"--privy-color-icon-default-clicked":e.iconDefaultClicked,"--privy-color-icon-muted-clicked":e.iconMutedClicked,"--privy-color-icon-subtle-clicked":e.iconSubtleClicked,"--privy-color-icon-default-disabled":e.iconDefaultDisabled,"--privy-color-icon-muted-disabled":e.iconMutedDisabled,"--privy-color-icon-subtle-disabled":e.iconSubtleDisabled,"--privy-color-icon-error-hover":e.iconErrorHover,"--privy-color-icon-interactive-hover":e.iconInteractiveHover,"--privy-color-icon-error-clicked":e.iconErrorClicked,"--privy-color-icon-interactive-clicked":e.iconInteractiveClicked,"--privy-color-icon-muted-disabled-alt":e.iconMutedDisabledAlt,"--privy-color-icon-subtle-disabled-alt":e.iconSubtleDisabledAlt,"--privy-border-radius-xs":"6px","--privy-border-radius-sm":"8px","--privy-border-radius-md":"12px","--privy-border-radius-mdlg":"16px","--privy-border-radius-lg":"24px","--privy-border-radius-full":"9999px","--privy-height-modal-full":"620px","--privy-height-modal-compact":"480px"};return(0,D.AH)`
    ${Object.entries(t).map(([e,t])=>`${e}: ${t};`).join("\n")}
  `},eB=D.I4.div`
  // css normalize only the privy application to avoid conflicts
  // with consuming application
  ${"\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n"}

  // Privy styles
  color: var(--privy-color-foreground-2);

  h3 {
    font-size: 16px;
    line-height: 24px;
    font-weight: 500;
    color: var(--privy-color-foreground-2);
  }

  h4 {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: var(--privy-color-foreground);
  }

  p {
    font-size: 13px;
    line-height: 20px;
    color: var(--privy-color-foreground-2);
  }

  button:focus,
  input:focus,
  optgroup:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--privy-color-accent-light);
    box-shadow: 0 0 0 3px var(--privy-color-border-focus);
  }

  .mobile-only {
    @media (min-width: 441px) {
      display: none;
    }
  }

  /* Animations */

  @keyframes fadein {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`,eV=({children:e,open:t,onClick:n,...r})=>(0,h.jsx)(z.e,{show:t,as:p.Fragment,children:(0,h.jsxs)(q.lG,{onClose:n,...r,as:e$,children:[(0,h.jsx)(z._,{as:p.Fragment,enterFrom:"entering",leaveTo:"leaving",children:(0,h.jsx)(eK,{id:"privy-dialog-backdrop","aria-hidden":"true"})}),(0,h.jsx)(eG,{children:(0,h.jsx)(z._,{as:p.Fragment,enterFrom:"entering",leaveTo:"leaving",children:(0,h.jsx)(q.Lj,{as:eY,children:e})})})]})}),eK=D.I4.div`
  position: fixed;
  inset: 0;

  transition: backdrop-filter 100ms ease;
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);

  &.entering,
  &.leaving {
    backdrop-filter: unset;
    -webkit-backdrop-filter: unset;
  }
`,e$=D.I4.div`
  position: relative;
  z-index: 999999;
`,eG=D.I4.div`
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  min-height: 100vh;
`,eY=D.I4.div`
  // reset some default dialog styles
  padding: 0;
  background: transparent;
  border: none;
  width: 100%;
  pointer-events: auto;

  outline: none;
  display: block;

  /*
   * Normally it is bad to mix media queries like this We are doing
   * this here specifically for animations to avoid weird jank.
   */
  /* Mobile animation is a bottom drawer */
  @media (max-width: 440px) {
    opacity: 1;
    transform: translate3d(0, 0, 0);
    transition: transform 200ms ease-in;
    position: fixed;
    bottom: 0;

    &.entering,
    &.leaving {
      opacity: 0;
      transform: translate3d(0, 100%, 0);
      transition:
        transform 150ms ease-in 0ms,
        opacity 0ms ease 150ms;
    }
  }

  /* Tablet/Desktop animation is a fade in */
  @media (min-width: 441px) {
    opacity: 1;
    transition: opacity 100ms ease-in;

    &.entering,
    &.leaving {
      opacity: 0;
      transition-delay: 5ms;
    }

    margin: auto;
    width: 360px;
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`;D.I4.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
`;let eJ=(0,p.lazy)(()=>Promise.all([n.e(4124),n.e(1919),n.e(7170),n.e(2987)]).then(n.bind(n,12987))),eQ=(0,p.lazy)(()=>ej.MfaAuthVerifyFlowScreen().then(e=>({default:e.default.component}))),eZ=()=>(0,h.jsx)(e5,{children:(0,h.jsx)(C.L,{})}),eX=()=>{let{currentScreen:e}=(0,A.a)(),t=ez(e=>e.inProgressMfaFlow),n=()=>ez.setState({inProgressMfaFlow:void 0}),{component:r,isLoading:a}=(()=>{let{ready:e}=(0,A.u)(),{currentScreen:t}=(0,A.a)(),[n,r]=(0,p.useState)(null),[a,i]=(0,p.useState)(!1),s=function(e){let[t,n]=(0,p.useState)(!1),r=(0,p.useRef)(null),a=(0,p.useRef)(null),i=(0,p.useRef)(null);return(0,p.useEffect)(()=>{if(r.current&&(clearTimeout(r.current),r.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)i.current=Date.now(),r.current=setTimeout(()=>{n(!0)},150);else if(null!==i.current){let e=Date.now()-i.current;e>=150?a.current=setTimeout(()=>{n(!1),i.current=null},Math.max(0,400-(e-150))):(r.current&&(clearTimeout(r.current),r.current=null),n(!1),i.current=null)}return()=>{r.current&&clearTimeout(r.current),a.current&&clearTimeout(a.current)}},[e]),t}(a);return(0,p.useEffect)(()=>{t?(i(!0),ej[t]().then(n=>{(!t||e||n.default.isShownBeforeReady)&&(r(()=>n.default.component),i(!1))}).catch(()=>{r(null),i(!1)})):(r(null),i(!1))},[t,e]),{component:n,isLoading:s}})();return function(){let{isModalOpen:e}=(0,A.u)(),{headless:t}=(0,I.u)(),{currentScreen:n}=(0,A.a)(),{status:r,execute:a,reset:i,enabled:s}=ex(),[o,l]=(0,p.useState)(!1);(0,p.useEffect)(()=>{!e&&s&&i()},[e,s,i]),(0,p.useEffect)(()=>{n?ej[n]().then(e=>{l(!!e.default.isCaptchaRequired)}).catch(()=>{l(!1)}):l(!1)},[n]),(0,p.useEffect)(()=>{e&&o&&!t&&"ready"===r&&s&&a()},[e,o,t,r,s,a])}(),e||"txn"!==t?a?(0,h.jsx)(eZ,{}):r?(0,h.jsxs)(h.Fragment,{children:[(0,h.jsx)(C.H,{$if:!!t,children:(0,h.jsx)(p.Suspense,{children:(0,h.jsx)(r,{})})}),(0,h.jsxs)(p.Suspense,{children:["txn"===t&&(0,h.jsx)(eJ,{onClose:n}),"auth"===t&&(0,h.jsx)(eQ,{})]})]}):null:(0,h.jsx)(p.Suspense,{children:(0,h.jsx)(eJ,{onClose:n})})},e0=()=>{let e=(0,p.useRef)(null);return(0,h.jsx)(e4,{style:{height:(0,C.u)(e)},id:"privy-modal-content",children:(0,h.jsx)("div",{ref:e,children:(0,h.jsx)(eX,{})})})},e1=({open:e})=>{var t;let n=(0,I.u)(),{gracefulClosePrivyModal:r}=(()=>{let{closePrivyModal:e}=(0,k.u)(),{onUserCloseViaDialogOrKeybindRef:t}=(0,A.a)();return{gracefulClosePrivyModal:(0,p.useCallback)(()=>{if(!t?.current)return e({shouldCallAuthOnSuccess:!1});t.current()},[e])}})(),a=ez(e=>e.inProgressMfaFlow);return t={onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||ez.setState({inProgressMfaFlow:"txn"})}},(0,L.u)("configureMfa",t),n.render.standalone?(0,h.jsx)(eB,{children:(0,h.jsx)(e2,{id:"privy-modal-content",children:(0,h.jsx)(eX,{})})}):(0,h.jsx)(eV,{open:!(!e&&!a),id:"privy-dialog","aria-label":"log in or sign up","aria-labelledby":"privy-dialog-title",onClick:()=>r(),children:(0,h.jsx)(eB,{children:(0,h.jsx)(e0,{})})})},e2=D.I4.div`
  display: flex;
  flex-direction: column;
  text-align: center;
  font-size: 14px;
  line-height: 20px;
  width: 100%;
  background: var(--privy-color-background);
  padding: 0 16px;
`,e4=(0,D.I4)(e2)`
  transition: height 150ms ease-out;
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none;

  // Ensure the modal gets pinned to the top if it ever gets too tall
  max-height: calc(100svh - 32px);

  border-radius: var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;
  box-shadow: 0px 0px 36px rgba(55, 65, 81, 0.15);

  @media (min-width: 441px) {
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`,e5=D.I4.div`
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  padding: 2rem;
`;function e3(e){let t=(0,p.useRef)(null),n=(0,p.useRef)();return(0,p.useEffect)(()=>{n.current?.remove(),n.current=function({botUsername:e,scriptHost:t}){let n=document.createElement("script"),{origin:r}=new URL(t);return n.async=!0,n.src=`${r}/js/telegram-login.js`,n.setAttribute("data-telegram-login",e),n.setAttribute("data-request-access","write"),n.setAttribute("data-lang","en"),n}(e),t.current?.after(n.current)},[e]),(0,h.jsx)("div",{ref:t,hidden:!0})}let e6=()=>{let{ready:e}=(0,_.u)(),{client:t}=(0,k.u)();return(0,p.useEffect)(()=>{let n=()=>{if(!t.connectors||!e)return;let n=t.connectors.wallets.map(e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id}));T.s.put(I.b,n)};return t.connectors?.on("walletsUpdated",n),()=>{t.connectors?.off("walletsUpdated",n)}},[e,t.connectors]),null};class e7 extends C.E{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=(0,C.g)(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:(0,C.s)(this.walletProvider?.session?.peer.metadata.name||"")||"WalletConnect",icon:"string"==typeof e?e:T.W,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||"wallet_connect_v2"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,(0,M.d)(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise((e,t)=>{(async()=>{let t="",n=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(n?.length&&(t=n[0]),!t||""===t)throw new k.P("Unable to retrieve address");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=(0,C.g)(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown",this.proxyProvider.rpcTimeoutDuration=(0,C.c)(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(n),e()})().catch(e=>{t(e?(0,T.f)(e):new k.P("Unknown error during connection"))})})}disconnect(){this.walletProvider?.disconnect().then(()=>this.onDisconnect()).catch(()=>console.warn("Unable to disconnect WalletConnect provider"))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let n=(0,C.a)(t.id,this.chains,this.rpcConfig,this.privyAppId);n&&(e[t.id]=n)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],n=this.chains.map(e=>e.id),r=await H.vd.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:n,optionalEvents:H.td,optionalMethods:H.C4,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return r.on("display_uri",e=>{if(r.signer.abortPairingAttempt(),(0,M.r)(),!this.showPrivyQrModal)throw new k.P("WalletConnect modal not available - Privy handles wallet connections through its own UI");if(W.Fr&&this.walletEntry){let{redirect:t,href:n}=(0,M.b)(e,this.walletEntry);(0,M.o)(t,"_self"),(0,M.s)({href:n,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let r=(0,M.a)(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=r?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=(0,M.a)(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})}),r.on("connect",()=>{r.session?.peer.metadata.url&&(this.walletEntry=(0,C.g)(r.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown")}),r}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await this.walletProvider?.enable()}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,shouldEnforceDefaultChainOnConnect:a,privyAppId:i,privyAppName:s,walletClientType:o}){super(o||"unknown",n,r,t),this.connectorType="wallet_connect_v2",this.privyAppId=i,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=a,this.proxyProvider=new C.P(void 0,this.rpcTimeoutDuration),o&&(this.walletEntry=(0,C.b)(o),this.walletClientType=o)}}let e8=["error","invalid_request_arguments","wallet_not_on_device","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","mfa_verification_max_attempts_reached","mfa_timeout","twilio_verification_failed"];class e9 extends Error{constructor(e,t){super(t),this.type=e}}function te(e){let t=e.type;return"string"==typeof t&&e8.includes(t)}function tt(e){return te(e)&&"wallet_not_on_device"===e.type}function tn(e){return te(e)&&("invalid_recovery_pin"===e.type||"invalid_request_arguments"===e.type)}function tr(e){return!!te(e)&&"mfa_timeout"===e.type}function ta(e){return!!te(e)&&"missing_or_invalid_mfa"===e.type}function ti(e){return!!te(e)&&"mfa_verification_max_attempts_reached"===e.type}function ts(e){return!(!te(e)||!e.message.includes("code 429"))}function to(e){let t;return"string"==typeof(t=e.type)&&"client_error"===t&&"MFA canceled"===e.message}async function tl(e,t,n,r,a,i=!1){let s=i,o=async o=>{if(s&&t&&t.length>0){o===+!i?a("configureMfa","onMfaRequired",{mfaMethods:t}):r.current?.reject(new e9("missing_or_invalid_mfa","MFA verification failed, retry."));let s=await new Promise((e,t)=>{n.current={resolve:e,reject:t},setTimeout(()=>{let e=new e9("mfa_timeout","Timed out waiting for MFA code");r.current?.reject(e),t(e)},3e5)});return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),r.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw r.current?.resolve(void 0),e;s=!0}if(null===l){let e=new e9("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw r.current?.reject(e),e}return l}let tc=(t9=0,()=>"id-"+t9++);function td(e){return void 0!==e.error}let tu=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let n=this.callbacks[t];if(!n)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:import":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":case"privy:auth:unlink-passkey":case"privy:farcaster:init-signer":case"privy:farcaster:sign":case"privy:solana-wallet:create":case"privy:delegated-actions:consent":return n;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},th=new Map,tp=(e,t)=>"bigint"==typeof t?t.toString():t;function tw(e,t,n,r){let a=n.contentWindow;if(!a)throw Error("iframe not initialized");let i=`${e}${JSON.stringify(t,tp)}`;if("privy:wallet:create"===e){let e=th.get(i);if(e)return e}let s=new Promise((n,i)=>{let s=tc();tu.enqueue(s,{resolve:n,reject:i}),a.postMessage({id:s,event:e,data:t},r)}).finally(()=>{th.delete(i)});return th.set(i,s),s}function tm(e){let t=(0,I.c)(),n=(0,p.useRef)(null),r=(0,p.useRef)(e.mfaMethods),a=(0,L.a)(),[i,s]=(0,p.useState)(!1);return(0,p.useEffect)(()=>{r.current=e.mfaMethods},[e.mfaMethods]),(0,p.useEffect)(()=>{if(!i)return;let t=n.current;if(!t)return;function s(t){var n;t&&t.origin===e.origin&&"string"==typeof(n=t.data).event&&/^privy:.+/.test(n.event)&&function(e){switch(e.event){case"privy:iframe:ready":let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data);case"privy:user-signer:sign":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:add":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:set-recovery":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:connect":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:recover":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:rpc":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallet:create":let n=tu.dequeue(e.event,e.id);return td(e)?n.reject(new e9(e.error.type,e.error.message)):n.resolve(e.data);case"privy:wallets:import":let r=tu.dequeue(e.event,e.id);return td(e)?r.reject(new e9(e.error.type,e.error.message)):r.resolve(e.data);case"privy:mfa:verify":let a=tu.dequeue(e.event,e.id);return td(e)?a.reject(new e9(e.error.type,e.error.message)):a.resolve(e.data);case"privy:mfa:init-enrollment":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:submit-enrollment":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:unenroll":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:clear":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:auth:unlink-passkey":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:solana-wallet:create":let i=tu.dequeue(e.event,e.id);return td(e)?i.reject(new e9(e.error.type,e.error.message)):i.resolve(e.data);case"privy:farcaster:init-signer":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:farcaster:sign":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:delegated-actions:consent":{let t=tu.dequeue(e.event,e.id);return td(e)?t.reject(new e9(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn("Unsupported wallet proxy method:",e)}}(t.data)}let o={signWithUserSigner:n=>tl(r=>tw("privy:user-signer:sign",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),addWallet:n=>tl(r=>tw("privy:wallets:add",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),setRecovery:n=>tl(r=>tw("privy:wallets:set-recovery",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),connect:n=>tl(r=>tw("privy:wallets:connect",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),recover:n=>tl(r=>tw("privy:wallets:recover",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a,!n.recoveryAccessToken&&!n.recoveryPassword&&!n.recoverySecretOverride),rpc:n=>tl(r=>tw("privy:wallets:rpc",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),create:n=>tw("privy:wallet:create",n,t,e.origin),importWallet:n=>tw("privy:wallets:import",n,t,e.origin),createSolana:n=>tl(r=>tw("privy:solana-wallet:create",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),createDelegatedAction:n=>tw("privy:delegated-actions:consent",n,t,e.origin),verifyMfa:n=>tl(r=>tw("privy:mfa:verify",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a,!0),initEnrollMfa:n=>tl(r=>tw("privy:mfa:init-enrollment",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),submitEnrollMfa:n=>tl(r=>tw("privy:mfa:submit-enrollment",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),unenrollMfa:n=>tl(r=>tw("privy:mfa:unenroll",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),clearMfa:n=>tw("privy:mfa:clear",n,t,e.origin),unlinkPasskeyAccount:n=>tl(r=>tw("privy:auth:unlink-passkey",{...n,...r},t,e.origin),r.current,e.mfaPromise,e.mfaSubmitPromise,a),initFarcasterSigner:n=>tw("privy:farcaster:init-signer",n,t,e.origin),signFarcasterMessage:n=>tw("privy:farcaster:sign",n,t,e.origin)};window.addEventListener("message",s);let l=new AbortController;return(0,C.i)(()=>tw("privy:iframe:ready",{},t,e.origin),{abortSignal:l.signal}).then(()=>e.onLoad(o),(...t)=>{console.warn("Privy iframe failed to load: ",...t),e.onLoadFailed()}),()=>{window.removeEventListener("message",s),l.abort()}},[i]),t?(0,h.jsx)("iframe",{ref:n,width:"0",height:"0",style:{display:"none",height:"0px",width:"0px"},onLoad:()=>s(!0),src:(0,B.j)({origin:e.origin,path:`/apps/${e.appId}/embedded-wallets`,query:{caid:e.clientAnalyticsId,client_id:e.appClientId}})}):null}let ty=e=>e.linkedAccounts.filter(e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated),tg="popup-privy-oauth",tf="PRIVY_OAUTH_USE_BROADCAST_CHANNEL";class tv{async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.o,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.g,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw(0,k.f)(e)}}constructor(e){this.meta=e}}async function tA({api:e,requesterAppId:t,providerAppId:n}){let r=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find(e=>e.provider_app_id===n);if(!r)throw new k.a("Invalid connected app");return{name:r.provider_app_name,logoUrl:r.provider_app_icon_url||void 0,apiUrl:r.provider_app_custom_api_url,readOnly:r.read_only,customAuthAuthorizeUrl:r.provider_app_custom_auth_authorize_url,customAuthTransactUrl:r.provider_app_custom_auth_transact_url}}let tb=async({user:e,address:t,client:n,request:r,requesterAppId:a,reconnect:i})=>{n.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:t,method:r.method}});let s=e?.linkedAccounts.find(e=>"cross_app"===e.type&&(e.embeddedWallets.some(e=>e.address===t)||e.smartWallets.some(e=>e.address===t)));if(!e||!s)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:t}}),new k.a("Cannot request a signature with this wallet address");let o=n.getProviderAccessToken(s.providerApp.id),l=await tA({api:n.api,requesterAppId:a,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error("cannot transact against a read-only provider app"),new k.a("Cannot transact against a read-only provider app");await i({appId:s.providerApp.id,action:"link"})&&(o=n.getProviderAccessToken(s.providerApp.id))}if(!o)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:t}}),new k.a("Transactions require a valid token");let c=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);c.searchParams.set("token",o||""),c.searchParams.set("request",tC(r));let d=(0,N.h)({location:c.href});if(!d)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:t}}),new k.a("Failed to initialize signature request");return new Promise((e,a)=>{let i=setTimeout(()=>{c(),a(new k.a("Request timeout")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:t}})},12e4),o=setInterval(()=>{d.closed&&(c(),a(new k.a("User rejected request")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:t}}))},300),l=i=>{i.data&&("set"===i.data.token?.action&&void 0!==i.data.token?.value?n.storeProviderAccessToken(s.providerApp.id,i.data.token.value):"clear"===i.data.token?.action&&n.storeProviderAccessToken(s.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===i.data.type&&i.data.result&&(c(),e(i.data.result),n.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:t,method:r.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===i.data.type&&i.data.error&&(c(),a(i.data.error),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:i.data.error,address:t}})))};window.addEventListener("message",l);let c=()=>{d.close(),clearInterval(o),clearTimeout(i),window.removeEventListener("message",l)}})},tC=e=>JSON.stringify({content:{request:{request:t_(e,U.nj)}},timestamp:Date.now(),callbackUrl:window.origin}),t_=(e,t)=>"bigint"==typeof e?t(e):Array.isArray(e)?e.map(e=>t_(e,t)):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map(([e,n])=>[e,t_(n,t)])):e;function tk({isCreatingWallet:e,skipSplashScreen:t}){return e?"EmbeddedWalletPasswordCreateScreen":t?"EmbeddedWalletPasswordUpdateScreen":"EmbeddedWalletPasswordUpdateSplashScreen"}function tT({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:n,isResettingPassword:r,showAutomaticRecovery:a}){return a?"SetAutomaticRecoveryScreen":n||1===t.length?tk({isCreatingWallet:"create"===e,skipSplashScreen:r}):"RecoverySelectionScreen"}function tE(e){switch(e){case"user-passcode":return"PasswordRecoveryScreen";case"google-drive":case"icloud":return"RecoveryOAuthScreen";default:throw Error("Recovery method not supported")}}function tS(e,t){if(e.onComplete)switch(t){case"external":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:"cancelled",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:"cancelled",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:"completed",address:e.address,fundingMethod:t,amount:e.amount})}}function tI(e,t,n,r,a,i,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:n,amount:e.funding.amount,assetType:a?i?.symbol||"ETH":s.nativeCurrency.symbol||"ETH",metadata:{walletClientType:r}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}}let tP=new Map([["FundingMethodSelectionScreen",null],["TransferFromWalletScreen","external"],["FundingAmountEditScreen","external"],["ConnectOnlyLandingScreen","external"],["ConnectOnlyStatusScreen","external"],["AwaitingExternalEthereumTransferScreen","external"],["AwaitingEvmToSolBridgingScreen","external"],["AwaitingSolToEvmBridgingScreen","external"],["ManualTransferScreen","manual"],["MoonpayStatusScreen","moonpay"]]);function tW(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||["fbav","fban","instagram","snapchat","linkedinapp"].some(e=>t.includes(e))}async function tU({rpc:e,address:t}){return(await e.getBalance(t,{commitment:"confirmed"}).send()).value??0n}let tx={apple_oauth:"apple",custom_auth:"custom",discord_oauth:"discord",email:"email",farcaster:"farcaster",github_oauth:"github",google_oauth:"google",instagram_oauth:"instagram",linkedin_oauth:"linkedin",passkey:"passkey",phone:"sms",spotify_oauth:"spotify",telegram:"telegram",tiktok_oauth:"tiktok",line_oauth:"line",twitch_oauth:"twitch",twitter_oauth:"twitter",wallet:"siwe",smart_wallet:"siwe",cross_app:"privy:"},tO=e=>{if((0,A.i)(e))return{displayName:e.replace("custom:",""),loginMethod:"custom"};let t=tx[e];return"wallet"===e||"phone"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}};async function tN(e,t,n,r){let a=(0,S._)(e),{chain:i,...s}=await (async()=>r?await r():await t.prepareTransactionRequest({...a,account:{address:n,type:"json-rpc"}}))();return{...s,type:S.k[s.type]}}let tR=({disabled:e})=>{let{migrate:t}=(()=>{let e=(0,I.u)(),{user:t}=(0,A.u)(),{client:n,refreshSessionAndUser:r,walletProxy:a}=(0,k.u)();return{migrate:(0,p.useCallback)(async()=>{if("legacy-embedded-wallets-only"===e.embeddedWallets.mode)return{success:!0,migrated:!1};if(!t)throw new k.a("User must be authenticated before migrating wallets",k.b.MUST_BE_AUTHENTICATED);if(!a)throw new k.a("Cannot connect to wallet proxy");let i=await n.getAccessToken();if(!i)throw new k.a("User must be authenticated before migrating wallets",k.b.MUST_BE_AUTHENTICATED);let s=t.linkedAccounts.filter(e=>"wallet"===e.type&&"privy"===e.walletClientType&&(0,T.i)(e)&&!(0,A.b)(e));if(0===s.length)return{success:!0,migrated:!1};let o=s.filter(e=>e.imported),l=s.filter(e=>!e.imported);if(l.length>0){let e=l.find(e=>"ethereum"===e.chainType&&0===e.walletIndex)??l.find(e=>"solana"===e.chainType&&0===e.walletIndex)??null;if(!e)throw new k.a("Primary wallet not found");let{entropyId:t,entropyIdVerifier:n}=(0,_.t)(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!tt(r)||"privy"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:l.map(e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}))})}for(let e of o){let{entropyId:t,entropyIdVerifier:n}=(0,_.t)(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!tt(r)||"privy"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await r(),{success:!0,migrated:!0}},[e.embeddedWallets.mode,t,a,n,r])}})(),{user:n}=(0,A.u)(),{walletProxy:r}=(0,k.u)(),a=(0,p.useRef)(!1);return(0,p.useEffect)(()=>{!e&&!a.current&&n&&r&&(a.current=!0,t().catch(e=>{console.debug("Unable to migrate wallets: ",e)}).finally(()=>{a.current=!1}))},[n,r,e,t]),null},tM=(0,j.v)(()=>({ethereum:[]}));class tF{async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.x,{token:this.meta.token})}catch(e){throw(0,k.f)(e)}}async link(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.y,{token:this.meta.token})}catch(e){throw(0,k.f)(e)}}constructor(e){this.meta={token:e}}}let tD=(e,t)=>!(0,A.c)(e)&&("all-users"===t||"users-without-wallets"===t&&!tL(e).length),tL=e=>e.linkedAccounts.filter(e=>"wallet"===e.type&&"ethereum"===e.chainType),tj=(e,t)=>!(0,A.d)(e)&&("all-users"===t||"users-without-wallets"===t&&!tz(e).length),tz=e=>e.linkedAccounts.filter(e=>"wallet"===e.type&&"solana"===e.chainType),tq=()=>{let{walletProxy:e,recoverEmbeddedWallet:t,setUser:n,refreshSessionAndUser:r,privy:a,client:i}=(0,k.u)(),s=(0,I.u)();return{create:async({walletIndex:o,chainType:l,latestUser:c,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})=>{let w=c;w||(w=await r());let m=await i.getAccessToken();if(!w||!m||!e)throw Error("User must be authenticated before creating a Privy wallet");return await (0,M.c)({appConfig:s,user:w,refreshSessionAndUser:r,privy:a,accessToken:m,proxy:e,recoverEmbeddedWallet:t,setUser:n,walletIndex:o,chainType:l,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})}}},tH=(0,j.v)(()=>({jwtAuthFlowState:{status:"not-enabled"}}));function tB({customAuth:e}){let{jwtAuthFlowState:t}=function({customAuth:e}){let t=(0,L.a)(),n=(0,p.useRef)(),r=(0,p.useCallback)(e=>(n.current=e,()=>{n.current=void 0}),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:i}=function({subscribe:e,getExternalJwt:t,enabled:n=!0,onAuthenticated:r,onUnauthenticated:a,onError:i}){let{client:s,setAuthenticated:o,setUser:l,setIsNewUser:c}=(0,k.u)(),{logout:d,authenticated:u,ready:h}=(0,M.u)(),{create:w}=tq(),m=(0,I.u)();if(!s)throw new k.a("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");let[y,g]=(0,p.useState)({status:"initial"}),f=(0,p.useRef)(),v=(0,p.useRef)(!1),A=(0,p.useRef)(t);(0,p.useEffect)(()=>{A.current=t},[t]);let b=(0,p.useRef)(r);(0,p.useEffect)(()=>{b.current=r},[r]);let C=(0,p.useRef)(a);(0,p.useEffect)(()=>{C.current=a},[a]);let _=(0,p.useRef)(i);(0,p.useEffect)(()=>{_.current=i},[i]);let T=(0,p.useRef)(w);(0,p.useEffect)(()=>{T.current=w},[w]);let E=(0,p.useRef)(m.embeddedWallets.ethereum.createOnLogin);(0,p.useEffect)(()=>{E.current=m.embeddedWallets.ethereum.createOnLogin},[m.embeddedWallets.ethereum.createOnLogin]);let S=(0,p.useRef)(m.embeddedWallets.solana.createOnLogin);(0,p.useEffect)(()=>{S.current=m.embeddedWallets.solana.createOnLogin},[m.embeddedWallets.solana.createOnLogin]);let P=(0,p.useRef)(l);(0,p.useEffect)(()=>{P.current=l},[l]);let W=(0,p.useRef)(c);(0,p.useEffect)(()=>{W.current=c},[c]);let U=(0,p.useRef)(o);return(0,p.useEffect)(()=>{U.current=o},[o]),(0,p.useEffect)(()=>{if(!n||!h)return;let t=async()=>{if(!v.current){v.current=!0;try{g({status:"loading"});let e=await A.current();if(void 0!==f.current&&f.current===e)return void g({status:"done"});if(!e)return u&&(await d(),C.current?.()),f.current=e,void g({status:"done"});s.startAuthFlow(new tF(e));let{user:t,isNewUser:n=!1}=await s.authenticate();if(!t)throw new k.a("Failed to sync with custom auth provider");b.current?.({user:t,isNewUser:n}),P.current(t),W.current(n),U.current(!0);let r=tD(t,E.current),a=tj(t,S.current);if(r&&a){let e=await T.current({chainType:"ethereum",walletIndex:0,latestUser:t});await T.current({chainType:"solana",walletIndex:0,latestUser:e.user})}else a?await T.current({chainType:"solana",walletIndex:0,latestUser:t}):r&&await T.current({chainType:"ethereum",walletIndex:0,latestUser:t});f.current=e,g({status:"done"})}catch(e){if(console.warn(e),await d().catch(()=>{}),C.current?.(),e instanceof k.e&&e.privyErrorCode===k.b.LINKED_TO_ANOTHER_USER)return g({status:"initial"}),void setTimeout(()=>{t()},0);_.current?.(e),g({status:"error",error:e})}finally{v.current=!1}}};return t(),e(t)},[e,s,u,d,n,h]),n?{state:y}:{state:{status:"not-enabled"}}}({enabled:!0===e?.enabled,subscribe:r,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:n})=>{t("login","onComplete",{user:e,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),t("customAuth","onAuthenticated",{user:e})},onUnauthenticated:()=>{t("customAuth","onUnauthenticated")},onError:e=>{t("login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR)}});return(0,p.useEffect)(()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()},[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:i}}({customAuth:e});return(0,p.useEffect)(()=>{tH.setState({jwtAuthFlowState:t})},[t]),null}let tV=(0,p.createContext)(!1),tK=e=>{let t=e.client,r=e.privy,a=(0,V.u)(),d=(0,I.u)();(0,C.d)((0,C.e)(d?.appearance.walletList??[]));let[u,w]=(0,p.useState)(!1),y=ez(e=>e.inProgressMfaFlow),[g,f]=(0,p.useState)(!1),[v,b]=(0,p.useState)(null),E=tM(e=>e.ethereum),[S,F]=(0,p.useState)(void 0),[D,j]=(0,p.useState)(!1),[z,q]=(0,p.useState)(null),[H,B]=(0,p.useState)(!1),[G,Y]=(0,p.useState)({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:k.n}),[J,Q]=(0,p.useState)({status:"initial"}),[Z,X]=(0,p.useState)({status:"initial"}),[ee,et]=(0,p.useState)({status:"initial"}),[en,er]=(0,p.useState)({status:"initial"}),[ea,ei]=(0,p.useState)({status:"initial"}),[eo,el]=(0,p.useState)({status:"initial"}),[eu,ep]=(0,p.useState)(null),ew=(0,I.c)(),[eg,eC]=(0,p.useState)({}),[eP,eW]=(0,p.useState)(null),ex=(0,p.useRef)(null),[eN,eF]=(0,p.useState)(!1),eD=(0,p.useRef)(null),eH=(0,p.useRef)(null),eB=(0,p.useRef)(L.p),[eV,eK]=(0,p.useState)(!1),[e$,eG]=(0,p.useState)(!1),eY=(0,p.useCallback)(e=>{eG(e),!e&&z&&ej[z]().then(e=>{e.default.isUnauthenticatedScreem&&q(null)})},[z]);t.onStoreCustomerAccessToken=e=>{e&&(0,L.e)(eB,"accessToken","onAccessTokenGranted",{accessToken:e})},t.onDeleteCustomerAccessToken=()=>{b(null),eY(!1),(0,L.e)(eB,"accessToken","onAccessTokenRemoved")};let eJ=(0,p.useRef)(null),eQ=(0,p.useRef)(null),eZ=(0,p.useRef)(!1),eX=({showWalletUIs:e})=>eZ.current?eZ.current:void 0!==e?!e:!d.embeddedWallets.showWalletUIs,e0=e=>{q(e),setTimeout(()=>{w(!0)},15)};(0,p.useEffect)(()=>{if(!v)return void t.connectors?.removeEmbeddedWalletConnectors();let n=(0,A.c)(v),a=(0,A.e)(v),i=(0,A.f)(v);n&&a.length||t.connectors?.removeEmbeddedWalletConnectors(),i.length||t.connectors?.removeImportedWalletConnectors(),t.connectors?eu?(n&&t.connectors.addEmbeddedWalletConnectors({walletProxy:eu,user:v,embeddedWallets:a,defaultChain:d.defaultChain,appId:e.appId,privyClient:r}),i.forEach(n=>t.connectors?.addImportedWalletConnector(eu,n.address,d.defaultChain,e.appId))):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")},[eu,v]),(0,p.useEffect)(()=>{eu&&ex.current?.(eu)},[eu]),(0,p.useEffect)(()=>{if(d.externalWallets.solana.connectors)return d.externalWallets.solana.connectors.onMount(),()=>d.externalWallets.solana.connectors?.onUnmount()},[d.externalWallets.solana.connectors]),(0,p.useEffect)(()=>{!g&&ew&&async function(){let e,n=e2(),r=e4(),a=(0,P.y)();t.initializeConnectorManager({walletConnectCloudProjectId:d.walletConnectCloudProjectId,rpcConfig:d.rpcConfig,chains:d.chains,defaultChain:d.defaultChain,store:a,walletList:d.appearance.walletList,shouldEnforceDefaultChainOnConnect:d.shouldEnforceDefaultChainOnConnect,externalWalletConfig:d.externalWallets,appName:d.name??"Privy",walletChainType:d.appearance.walletChainType,setBaseAccountSdk:F}),t.connectors?.on("connectorInitialized",()=>{e&&clearTimeout(e);let n=t.connectors.walletConnectors.length,r=t.connectors.walletConnectors.reduce((e,t)=>e+ +!!t.initialized,0);r===n?eK(!0):e=setTimeout(()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:n}),eK(!0)},1500)}),t.connectors?.initialize().then(()=>{tn()});let i=await t.getAuthenticatedUser(),s=!!i;d.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await t.logout(),tp.setReadyToTrue(!0),(0,L.e)(eB,"logout","onSuccess")):(d.customAuth?.enabled||(eY(!!i),i&&(0,L.e)(eB,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),b(i)),n?eQ.current=s?"link":"login":r&&!s?(eQ.current="login",eC({telegramAuthModalData:{seamlessAuth:!0}}),e0("TelegramAuthScreen")):tp.setReadyToTrue(!!i))}()},[t,eP,g,ew]),(0,p.useEffect)(()=>{if(g){if(!v||!v.linkedAccounts.find(e=>"wallet"===e.type&&"privy"===e.walletClientType))return void eF(!!eu);if([...E].some(e=>"privy"===e.walletClientType))return void eF(!0);eF(!!eu)}},[g,v,E,eu]),(0,p.useEffect)(()=>{t.connectors?.setWalletList(d.appearance.walletList)},[d.appearance.walletList.join()]);let e2=()=>{let e=function(){let e=new URLSearchParams(window.location.search),t=e.get("privy_oauth_code"),n=e.get("privy_oauth_state"),r=e.get("privy_oauth_provider");if(!t||!n||!r)return{inProgress:!1};let a=!1;try{a=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:n,provider:r,withPrivyUi:!T.s.get(I.H),popupFlow:null!==window.opener&&a,disableSignup:!!T.s.get(I.O)}}();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith("privy:")&&!e.popupFlow&&(new BroadcastChannel(tg).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(t.startAuthFlow(new eb({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl})),e0("OAuthStatusScreen"),!0))},e4=()=>{let e,n=(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get("id")||""),n=e.get("hash"),r=Number(e.get("auth_date")||""),a=e.get("first_name");if(t&&a&&r&&n)return Object.fromEntries(e.entries())}())?(eM(),{flowType:"login-url",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith("#tgWebAppData"))return;let t=eR(e.replace("#tgWebAppData=","")),{user:n,auth_date:r,hash:a}=t;return n&&r&&a?t:void 0}())?(eM(),{flowType:"web-app",authData:e}):void 0;if(!n||!d.loginMethods.telegram||!d.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let r=new eO;return t.startAuthFlow(r),"login-url"===n.flowType&&(r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=n.authData),"web-app"===n.flowType&&(r.meta.telegramAuthResult=void 0,r.meta.telegramWebAppData=n.authData),!0},e5=async(e,n,r,a)=>{if("solana_adapter"!==e)e8(await t.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:n})||null,n,r,a);else{let e=t.connectors?.findSolanaWalletConnector(n);if(!e)return;e8(e,n,r,a)}};async function e8(e,t,n,r){if(!e)return Y({status:"disconnected",connectedWallet:null,connectError:new k.P("Unable to connect to wallet."),connector:null,connectRetry:k.n}),r?.(null,n);Y({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:k.n}),e instanceof e7&&t&&await e.resetConnection(t),Y({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>e8(e,t,n,r)});try{let t=await e.connect({showPrompt:!0});if((!t||(0,C.f)(t))&&d.shouldEnforceDefaultChainOnConnect&&!d.chains.find(e=>e.id===Number(t?.chainId.replace("eip155:","")))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Y(t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:k.n}));try{await t?.switchChain(d.defaultChain.id),t&&(t.chainId=(0,C.l)((0,U.nj)(d.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${d.defaultChain.id}`)}}return Y(e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:k.n})),t&&(0,L.e)(eB,"connectWallet","onSuccess",{wallet:t}),r?.(t,n)}catch(e){return e instanceof k.c?(console.warn(e.cause?e.cause:e.message),(0,L.e)(eB,"connectWallet","onError",e.privyErrorCode||k.b.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),(0,L.e)(eB,"connectWallet","onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR)),Y(t=>({...t,status:"disconnected",connectedWallet:null,connectError:e})),r?.(null,n)}}let e9=async(e,n,r)=>{if(null===e||!(0,C.f)(e))return;let a=new eT(t,e,n,r);t.startAuthFlow(a)},te=async(e,n,r,i="plain")=>{let s=a(M.e);if("transaction"===i&&!s)throw new k.a("useSolanaLedger plugin hook must be mounted");if(null===e||!(0,C.n)(e))return;let o=new eE(e,t,n,r,i,s);t.startAuthFlow(o)},tn=async()=>{let e=new URLSearchParams(window.location.search),n=e.get("privy_connector"),r=e.get("privy_wallet_client"),a="true"===e.get("privy_connect_only");if(!n||!r)return;let i=(0,C.m)({connectorType:n,walletClientType:r});if(!i||!i.isInstalled)return e0("LoginFailedScreen");if(!t.connectors)throw new k.a("Connector not initialized");await e0(a?"ConnectOnlyStatusScreen":"ConnectionStatusScreen");let s=new URL(window.location.href);s.searchParams.delete("privy_connector"),s.searchParams.delete("privy_wallet_client"),s.searchParams.delete("privy_connect_only"),window.history.pushState({},"",s),e5(n,r,void 0,a?void 0:"solana_adapter"===n?te:e9)};(0,p.useEffect)(()=>{g&&e$&&null===v&&t.getAuthenticatedUser().then(b)},[g,e$,v,t]);let tr=e=>{if(!e$)throw(0,L.e)(eB,"linkAccount","onError",k.b.MUST_BE_AUTHENTICATED,{linkMethod:e}),new k.a("User must be authenticated before linking an account.")},ta=()=>{tM.setState(e=>{let n=t.connectors?.wallets.filter(C.f).map(e=>({...e,linked:(e=>{if(!e$||!v)return!1;if("privy"===e.walletClientType)return!0;for(let t of v.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1})(e),loginOrLink:async()=>{if(!await e.isConnected())throw new k.a("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new k.a("Cannot link or login with embedded wallet");(async e=>{let n;if(!t.connectors)throw new k.a("Connector not initialized");n="ethereum"===e.type?t.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:t.connectors.findSolanaWalletConnector(e.walletClientType)||null,Y(t=>({...t,connector:n,status:"connected",connectedWallet:e,connectError:null,connectRetry:k.n})),d.captcha.enabledProvider&&!e$?(eC({captchaModalData:{callback:t=>(0,C.f)(e)?e9(e,t):te(e,t),userIntentRequired:!1,onSuccessNavigateTo:"ConnectionStatusScreen",onErrorNavigateTo:"ErrorScreen"}}),await e0("CaptchaScreen")):((0,C.f)(e)?await e9(e):await te(e),await e0("ConnectionStatusScreen"))})(e)},fund:async t=>{await tp.fundWallet(e.address,t)},unlink:async()=>{if(!e$)throw new k.a("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new k.a("Cannot unlink an embedded wallet");b(await t.unlinkEthereumWallet(e.address))}}))||[];return(0,C.h)(e.ethereum,n)?{}:{ethereum:n}})};(0,p.useEffect)(()=>{ta()},[v?.linkedAccounts,e$,g]),(0,p.useEffect)(()=>{if(g){if(!t.connectors)throw new k.a("Connector not initialized");ta(),t.connectors.on("walletsUpdated",ta)}},[g]),(0,p.useEffect)(()=>{[...d.loginMethodsAndOrder?.primary??[],...d.loginMethodsAndOrder?.overflow??[]].filter(e=>e.startsWith("privy:")).forEach(e=>t.getCrossAppProviderDetails(e.replace("privy:","")))},[!!t]);let ti=({transaction:n,sponsor:i,uiOptions:s,fundWalletConfig:o,address:l,signOnly:c})=>new Promise(async(u,h)=>{let{requesterAppId:p}=s||{},w=c?"signTransaction":"sendTransaction",y=l?(0,A.h)(v,l):(0,A.c)(v);if(!y&&l){let e=(0,A.j)(tM.getState().ethereum,l);if(e){if(i)throw new k.a("Cannot sponsor transactions for externally connected wallet.");try{let t=await e.getEthereumProvider(),r=n.data,i=a(K.D);i&&(r=i.appendDataSuffix({data:r}));let s={...n,from:l,chainId:n.chainId||Number(e.chainId.replace("eip155:","")),value:void 0!==n.value?(0,U.nj)(n.value):void 0,data:r},o=await t.request({method:"sendTransaction"===w?"eth_sendTransaction":"eth_signTransaction",params:[s]});return(0,L.e)(eB,w,"onSuccess",{hash:o}),void u({hash:o})}catch(e){return(0,L.e)(eB,w,"onError",k.b.TRANSACTION_FAILURE),void h(e??new T.P("Unable to "+w+e))}}}if(!y)return(0,L.e)(eB,w,"onError",k.b.EMBEDDED_WALLET_NOT_FOUND),void h(new k.a("No embedded or connected wallet found for address."));if(!e$||!v)return(0,L.e)(eB,w,"onError",k.b.MUST_BE_AUTHENTICATED),void h(Error("User must be authenticated before signing with a Privy wallet"));let g=y.address,f=y.walletIndex??0,{entropyId:b,entropyIdVerifier:E}=(0,_.g)(v,y),S=tw.wallets.find(e=>"privy"===e.walletClientType&&(0,x.b)(e.address)===(0,x.b)(g));if(!S)return(0,L.e)(eB,w,"onError",k.b.EMBEDDED_WALLET_NOT_FOUND),void h(Error("Must have a Privy wallet before signing"));let I=await S.getEthereumProvider(),P=await I.request({method:"eth_chainId"}),W=n.chainId?Number(n.chainId):(0,T.e)(P);if(!d.chains.map(e=>e.id).includes(W))throw new k.P(`Chain ID ${W} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,k.b.UNSUPPORTED_CHAIN_ID);let N=n.data,R=a(K.D);R&&(N=R.appendDataSuffix({data:N}));let M={...n,from:n.from??g,chainId:W,data:N},F=await es();if(!F||!eu)return(0,L.e)(eB,w,"onError",k.b.EMBEDDED_WALLET_NOT_FOUND),void h(Error("Must have valid access token and Privy wallet to send transaction"));let D=(0,$.g)(M.chainId,d.chains,d.rpcConfig,{appId:e.appId}),j=(0,A.b)(y),z=async({transactionRequest:e})=>{try{let t;if(!await tp.recoverEmbeddedWallet({address:g}))throw(0,L.e)(eB,w,"onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR),h(Error("Unable to connect to wallet")),Error("Unable to connect to wallet");if(i){let t=await (async({transactionRequest:e})=>{if(!j)throw new k.a("Sponsoring is only supported for wallets on the TEE stack");if(c)throw new k.a("Cannot sponsor a sign transaction request");let t=e=>null==e?void 0:(0,U.nj)(e),n=await (0,m._)(r,async({message:e})=>await eu.signWithUserSigner({accessToken:F,requesterAppId:p,message:e}),{chain_type:"ethereum",method:"eth_sendTransaction",caip2:(0,C.l)((0,U.nj)(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:(0,O.q)(e.data)?e.data?e.data:(0,U.nj)(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:y.id});if(n.data&&"hash"in n.data)return n.data.hash;throw new T.P("Unable to sign transaction")})({transactionRequest:e});return(0,L.e)(eB,"sendTransaction","onSuccess",{hash:t}),t}if(j){let n=e=>null==e?void 0:(0,U.nj)(e),a=await (0,m._)(r,async({message:e})=>await eu.signWithUserSigner({accessToken:F,requesterAppId:p,message:e}),{chain_type:"ethereum",method:"eth_signTransaction",params:{transaction:{from:e.from,to:e.to,nonce:n(e.nonce),chain_id:n(e.chainId),data:(0,O.q)(e.data)?e.data?e.data:(0,U.nj)(Uint8Array.from(e.data)):void 0,value:n(e.value),type:e.type,gas_limit:n(e.gasLimit??e.gas),gas_price:n(e.gasPrice??e.gas),max_fee_per_gas:n(e.maxFeePerGas),max_priority_fee_per_gas:n(e.maxPriorityFeePerGas)}},wallet_id:y.id});if(!a.data||!("signed_transaction"in a.data))throw new T.P("Unable to sign transaction");t=a.data.signed_transaction}else t=await async function({accessToken:e,entropyId:t,entropyIdVerifier:n,transactingWalletIndex:r,walletProxy:a,transactionRequest:i,requesterAppId:s}){return(await a.rpc({entropyId:t,entropyIdVerifier:n,hdWalletIndex:r??0,chainType:"ethereum",accessToken:e,requesterAppId:s,request:{method:"eth_signTransaction",params:[i]}})).response.data}({accessToken:F,entropyId:b,entropyIdVerifier:E,transactingWalletIndex:f,walletProxy:eu,transactionRequest:e,requesterAppId:p});if(c)return(0,L.e)(eB,"signTransaction","onSuccess",{signature:t}),t;{let e=await D.sendRawTransaction({serializedTransaction:t});return(0,L.e)(eB,"sendTransaction","onSuccess",{hash:e}),e}}catch(e){throw(0,L.e)(eB,w,"onError",k.b.TRANSACTION_FAILURE),e}};if(eX({showWalletUIs:s?.showWalletUIs})){let e=c||i?M:await tN(M,D,M.from);try{let t=await z({transactionRequest:e});c?(0,L.e)(eB,"signTransaction","onSuccess",{signature:t}):(0,L.e)(eB,"sendTransaction","onSuccess",{hash:t}),u({hash:t})}catch(e){(0,L.e)(eB,w,"onError",k.b.TRANSACTION_FAILURE),h(e)}}else{let e={connectingWalletAddress:g,recoveryMethod:y.recoveryMethod,entropyId:b,entropyIdVerifier:E,onCompleteNavigateTo:"SendTransactionScreen",isUnifiedWallet:j,onFailure:e=>{(0,L.e)(eB,w,"onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR),h(e)}},n=d.fundingConfig&&(0,T.a)(d.fundingConfig.options).length>=1?(0,T.p)({address:g,appConfig:d,fundWalletConfig:o,methodScreen:"FundingMethodSelectionScreen",chainIdOverride:M.chainId,comingFromSendTransactionScreen:!0}):void 0;eC({connectWallet:e,sendTransaction:{transactionRequest:M,transactingWalletIndex:f,transactingWalletAddress:g,entropyId:b,entropyIdVerifier:E,signOnly:c,scanTransaction:async()=>{let e=await tN(M,D,M.from);return await t.scanTransaction({metadata:{domain:d.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!i,onConfirm:({transactionRequest:e})=>z({transactionRequest:e}),onSuccess:e=>{c?(0,L.e)(eB,"signTransaction","onSuccess",{signature:e.hash}):(0,L.e)(eB,"sendTransaction","onSuccess",{hash:e.hash}),u(e)},onFailure:e=>{(0,L.e)(eB,w,"onError",k.b.TRANSACTION_FAILURE),h(e)},uiOptions:s||{},fundWalletConfig:o,requesterAppId:p},funding:n}),e0("EmbeddedWalletConnectingScreen")}});function ts(){return new Promise(async(e,t)=>{let n=await es();if(!n||!eu)throw Error("Must have valid access token to enroll in MFA");try{await eu.verifyMfa({accessToken:n}),e()}catch(e){t(e)}})}let to=e=>e?.linkedAccounts.filter(e=>null!==e.latestVerifiedAt&&("wallet"!==e.type||"privy"!==e.walletClientType)).sort((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())[0],tl=e=>{let t=v?.linkedAccounts.filter(t=>t.type===e).length??0,{displayName:n,loginMethod:r}=tO(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw(0,L.e)(eB,"linkAccount","onError",k.b.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new k.a(`User already has an account of type ${n} linked.`)};async function tc({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){q(null);let n=t?"setWalletPassword":"setWalletRecovery";if(!e$||!v)throw(0,L.e)(eB,n,"onError",k.b.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=(0,A.g)(v);if(!r||!eu)throw(0,L.e)(eB,n,"onError",k.b.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");let a=(0,A.b)(r);if(a)throw(0,L.e)(eB,n,"onError",k.b.UNSUPPORTED_WALLET_TYPE),new k.a("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");try{await ts()}catch(e){throw(0,L.e)(eB,n,"onError",k.b.MISSING_MFA_CREDENTIALS),e}return new Promise((i,s)=>{let o="user-passcode"===r.recoveryMethod,l=tT({walletAction:"update",availableRecoveryMethods:d.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:u}=(0,_.g)(v),h={recoveryMethod:r.recoveryMethod,connectingWalletAddress:r.address,onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,isUnifiedWallet:a,entropyIdVerifier:u,onFailure:e=>{(0,L.e)(eB,n,"onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};eC({setWalletPassword:{onSuccess:e=>{(0,L.e)(eB,n,"onSuccess",{method:"user-passcode",wallet:e}),i(e)},onFailure:e=>{(0,L.e)(eB,n,"onError",k.b.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:c,entropyIdVerifier:u,onFailure:s},connectWallet:h,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),e0("EmbeddedWalletConnectingScreen")})}async function td({appId:e,action:n,disableSignup:r}){let a=await es();if("link"===n&&!a)throw(0,L.e)(eB,"linkAccount","onError",k.b.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new k.a("User must be authenticated before linking an account.");if("login"===n&&a)throw(0,L.e)(eB,"login","onError",k.b.UNKNOWN_AUTH_ERROR),new k.a("Attempted to log in, but user is already logged in. Use a `link` helper instead.");eJ.current=`privy:${e}`,eQ.current=n;let i=(0,N.h)();return t.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise(async(a,s)=>{let{name:o,logoUrl:l}=await tA({api:t.api,providerAppId:e,requesterAppId:d.id});eC({crossAppAuth:{appId:e,name:o,logoUrl:l,action:n,popup:i,disableSignup:r,onSuccess:a,onError:s}}),e0("CrossAppAuthScreen")})}let tu={ready:g,authenticated:e$,user:v,walletConnectors:t.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),eC({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),e0("ConnectOnlyLandingScreen")},linkWallet:e=>(e&&"target"in e&&e&&(e=void 0),tr("siwe"),eJ.current="siwe",eQ.current="link",eC({...eg,externalConnectWallet:{...eg.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${d?.name} account`}}),e0("AuthenticateWithWalletScreen")),startCrossAppAuthFlow:td,linkEmail:()=>{tr("email"),tl("email"),eJ.current="email",eQ.current="link",e0("LinkEmailScreen")},linkPhone:()=>{tr("sms"),tl("phone"),eJ.current="sms",eQ.current="link",e0("LinkPhoneScreen")},linkGoogle:async()=>{tr("google"),tl("google_oauth"),eQ.current="link",await tp.initLoginWithOAuth("google")},linkTwitter:async()=>{tr("twitter"),tl("twitter_oauth"),eQ.current="link",await tp.initLoginWithOAuth("twitter")},linkTwitch:async()=>{tr("twitch"),tl("twitch_oauth"),eQ.current="link",await tp.initLoginWithOAuth("twitch")},linkDiscord:async()=>{tr("discord"),tl("discord_oauth"),eQ.current="link",await tp.initLoginWithOAuth("discord")},linkGithub:async()=>{tr("github"),tl("github_oauth"),eQ.current="link",await tp.initLoginWithOAuth("github")},linkSpotify:async()=>{tr("spotify"),tl("spotify_oauth"),eQ.current="link",await tp.initLoginWithOAuth("spotify")},linkInstagram:async()=>{tr("instagram"),tl("instagram_oauth"),eQ.current="link",await tp.initLoginWithOAuth("instagram")},linkTiktok:async()=>{tr("tiktok"),tl("tiktok_oauth"),eQ.current="link",await tp.initLoginWithOAuth("tiktok")},linkLine:async()=>{tr("line"),tl("line_oauth"),eQ.current="link",await tp.initLoginWithOAuth("line")},linkLinkedIn:async()=>{tr("linkedin"),tl("linkedin_oauth"),eQ.current="link",await tp.initLoginWithOAuth("linkedin")},linkApple:async()=>{tr("apple"),tl("apple_oauth"),eQ.current="link",await tp.initLoginWithOAuth("apple")},linkPasskey:async()=>{tr("passkey"),tl("passkey"),await tp.initLinkWithPasskey(),e0("LinkPasskeyScreen")},linkTelegram:async e=>{if(tr("telegram"),tl("telegram"),eQ.current="link",eJ.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let n=new eO;t.startAuthFlow(n),n.meta.telegramAuthResult=void 0,n.meta.telegramWebAppData=eR(e.launchParams.initDataRaw),eC({telegramAuthModalData:{seamlessAuth:!0}}),e0("TelegramAuthScreen")}else(0,L.e)(eB,"linkAccount","onError",k.b.INVALID_DATA,{linkMethod:"telegram"});else await tp.initLoginWithTelegram();e0("TelegramAuthScreen")},linkFarcaster:async()=>{tr("farcaster"),tl("farcaster"),await tp.initLoginWithFarcaster(),eQ.current="link",eJ.current="farcaster",e0("FarcasterConnectStatusScreen")},updateEmail:()=>{if(tr("email"),!v?.email)throw new k.a("User does not have an email linked to their account.");eQ.current="update",eJ.current="email",e0("UpdateEmailScreen")},updatePhone:()=>{if(tr("sms"),!v?.phone)throw new k.a("User does not have a phone number linked to their account.");eQ.current="update",eJ.current="sms",e0("UpdatePhoneScreen")},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!g){let e=await new Promise(e=>{eW(t=>e.bind(t))});if(eW(null),e)return void console.warn(t)}!v||v.isGuest?(eQ.current="login",eC({login:e}),e0("LandingScreen")):console.warn(t)},connectOrCreateWallet:async()=>{g||(await new Promise(e=>{eW(()=>e)}),eW(null)),e$?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(eQ.current="connect-or-create",e0("ConnectOrCreateScreen"))},logout:async()=>{if(eQ.current=null,eJ.current=null,v&&t.clearProviderAcccessTokens(v),q(null),await t.logout(),v&&eu)try{await eu.clearMfa({userId:v.id})}catch(e){}b(null),eY(!1),X({status:"initial"}),et({status:"initial"}),Q({status:"initial"}),er({status:"initial"}),ei({status:"initial"}),el({status:"initial"}),(0,L.e)(eB,"logout","onSuccess"),w(!1),T.s.del(I.d),T.s.del((0,I.g)(d.id))},getAccessToken:(0,p.useCallback)(async()=>{let e=await t.getCustomerAccessToken();return e&&!e$&&eY(!0),e},[t,e$]),unlinkWallet:async e=>{let n;return b(n=e.startsWith("0x")?await t.unlinkEthereumWallet(e):await t.unlinkSolanaWallet(e)),n},unlinkEmail:async e=>{let n=await t.unlinkEmail(e);return b(n),n},unlinkPhone:async e=>{let n=await t.unlinkPhone(e);return b(n),n},unlinkGoogle:async e=>{let n=await t.unlinkOAuth("google",e);return b(n),n},unlinkTwitter:async e=>{let n=await t.unlinkOAuth("twitter",e);return b(n),n},unlinkTwitch:async e=>{let n=await t.unlinkOAuth("twitch",e);return b(n),n},unlinkDiscord:async e=>{let n=await t.unlinkOAuth("discord",e);return b(n),n},unlinkGithub:async e=>{let n=await t.unlinkOAuth("github",e);return b(n),n},unlinkSpotify:async e=>{let n=await t.unlinkOAuth("spotify",e);return b(n),n},unlinkInstagram:async e=>{let n=await t.unlinkOAuth("instagram",e);return b(n),n},unlinkTiktok:async e=>{let n=await t.unlinkOAuth("tiktok",e);return b(n),n},unlinkLine:async e=>{let n=await t.unlinkOAuth("line",e);return b(n),n},unlinkLinkedIn:async e=>{let n=await t.unlinkOAuth("linkedin",e);return b(n),n},unlinkApple:async e=>{let n=await t.unlinkOAuth("apple",e);return b(n),n},unlinkFarcaster:async e=>{let n=await t.unlinkFarcaster(e);return b(n),n},unlinkTelegram:async e=>{let n=await t.unlinkTelegram(e);return b(n),n},unlinkPasskey:async e=>{let n=await es();if(!n)throw Error("Must have valid access token to enroll in MFA");if(!eu)throw Error("Wallet proxy not initialized.");let r=d.passkeys.shouldUnenrollMfaOnUnlink;await eu.unlinkPasskeyAccount({credentialId:e,accessToken:n,removeAsMfa:r});let a=await t.getAuthenticatedUser();return b(a),a},unlinkCrossAppAccount:async({subject:e})=>{let n=v?.linkedAccounts.find(t=>"cross_app"===t.type&&t.subject===e)?.providerApp;if(!n)throw new k.a("Invalid subject");t.storeProviderAccessToken(n.id,null);let r=await t.unlinkOAuth(`privy:${n.id}`,e);return b(r),r},setWalletRecovery:async e=>tc({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>tc({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,n)=>new Promise(async(a,i)=>{let{requesterAppId:s}=n?.uiOptions||{},o=e.message,l=n?.address?(0,A.h)(v,n.address):(0,A.c)(v);if(!l&&void 0!==n?.address){let e=(0,A.j)(tM.getState().ethereum,n.address);if(e)try{let t=await e.getEthereumProvider(),n=await t.request({method:"personal_sign",params:[o,e.address]});return(0,L.e)(eB,"signMessage","onSuccess",{signature:n}),void a({signature:n})}catch(e){return(0,L.e)(eB,"signMessage","onError",k.b.UNABLE_TO_SIGN),void i(e??new T.P("Unable to sign message"))}}if(!l)throw new k.a("No embedded or connected wallet found for address.");if(!e$||!v)return(0,L.e)(eB,"signMessage","onError",k.b.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let c=l.address,d=l.walletIndex??0,{entropyId:u,entropyIdVerifier:h}=(0,_.g)(v,l),p=(0,A.b)(l);if("string"!=typeof o||o.length<1)return(0,L.e)(eB,"signMessage","onError",k.b.INVALID_MESSAGE),void i(Error("Message must be a non-empty string"));let w=async()=>{let n;if(!e$)throw Error("User must be authenticated before signing with a Privy wallet");let a=await es();if(!eu||!a||!await tp.recoverEmbeddedWallet({address:c}))throw Error("Unable to connect to wallet");if(t.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:c,requesterAppId:s}}),p){let t=(0,O.q)(e.message,{strict:!0}),i=await (0,m._)(r,async({message:e})=>await eu.signWithUserSigner({accessToken:a,requesterAppId:s,message:e}),{chain_type:"ethereum",method:"personal_sign",params:t?{message:o.slice(2),encoding:"hex"}:{message:o,encoding:"utf-8"},wallet_id:l.id});if(!i.data||!("signature"in i.data))throw new T.P("Unable to sign message");n=i.data.signature}else{let{response:e}=await eu.rpc({accessToken:a,entropyId:u,entropyIdVerifier:h,chainType:"ethereum",hdWalletIndex:d,requesterAppId:s,request:{method:"personal_sign",params:[o,c]}});n=e.data}return t.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:c,requesterAppId:s}}),n};if(eX({showWalletUIs:n?.uiOptions?.showWalletUIs}))try{let e=await w();(0,L.e)(eB,"signMessage","onSuccess",{signature:e}),a({signature:e})}catch(e){(0,L.e)(eB,"signMessage","onError",k.b.UNABLE_TO_SIGN),i(e??new T.P("Unable to sign message"))}else eC({signMessage:{method:"personal_sign",data:o,confirmAndSign:w,onSuccess:e=>{(0,L.e)(eB,"signMessage","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{(0,L.e)(eB,"signMessage","onError",k.b.UNABLE_TO_SIGN),i(e)},uiOptions:n?.uiOptions||{}},connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:c,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:"SignRequestScreen",isUnifiedWallet:p,onFailure:e=>{(0,L.e)(eB,"signMessage","onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),e0("EmbeddedWalletConnectingScreen")}),signTypedData:(e,n)=>new Promise(async(a,i)=>{let{requesterAppId:s}=n?.uiOptions||{},o=n?.address?(0,A.h)(v,n.address):(0,A.c)(v);if(!o&&n?.address){let t=(0,A.j)(tM.getState().ethereum,n.address);if(t)try{let n=await t.getEthereumProvider(),r=(0,C.j)(e),i=await n.request({method:"eth_signTypedData_v4",params:[t.address,r]});return(0,L.e)(eB,"signTypedData","onSuccess",{signature:i}),void a({signature:i})}catch(e){return(0,L.e)(eB,"signTypedData","onError",k.b.UNABLE_TO_SIGN),void i(e??new T.P("Unable to sign typed data "+e))}}if(!o)throw new k.a("No embedded or connected wallet found for address.");if(!e$||!v)return(0,L.e)(eB,"signTypedData","onError",k.b.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let l=o.address,c=o.walletIndex??0,{entropyId:d,entropyIdVerifier:u}=(0,_.g)(v,o),h=(0,A.b)(o),p=(0,C.j)(e),w=async()=>{let e;if(!e$)throw Error("User must be authenticated before signing with a Privy wallet");let n=await es();if(!eu||!n||!await tp.recoverEmbeddedWallet({address:l}))throw Error("Unable to connect to wallet");if(t.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:l,requesterAppId:s}}),h){let{domain:t,types:a,primaryType:i,message:l}=p,c=await (0,m._)(r,async({message:e})=>await eu.signWithUserSigner({accessToken:n,requesterAppId:s,message:e}),{chain_type:"ethereum",method:"eth_signTypedData_v4",params:{typed_data:{domain:t,types:a,primary_type:i,message:l}},wallet_id:o.id});if(!c.data||!("signature"in c.data))throw new T.P("Unable to sign message");e=c.data.signature}else{let{response:t}=await eu.rpc({accessToken:n,entropyId:d,entropyIdVerifier:u,chainType:"ethereum",hdWalletIndex:c,requesterAppId:s,request:{method:"eth_signTypedData_v4",params:[l,p]}});e=t.data}return t.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:l,requesterAppId:s}}),e};if(eX({showWalletUIs:n?.uiOptions?.showWalletUIs}))try{let e=await w();(0,L.e)(eB,"signTypedData","onSuccess",{signature:e}),a({signature:e})}catch(e){(0,L.e)(eB,"signTypedData","onError",k.b.UNABLE_TO_SIGN),i(e??new T.P("Unable to sign message"))}else eC({signMessage:{method:"eth_signTypedData_v4",data:p,confirmAndSign:w,onSuccess:e=>{(0,L.e)(eB,"signTypedData","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{(0,L.e)(eB,"signTypedData","onError",k.b.UNABLE_TO_SIGN),i(e)},uiOptions:n?.uiOptions||{}},connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,entropyId:d,isUnifiedWallet:h,entropyIdVerifier:u,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{(0,L.e)(eB,"signMessage","onError",k.b.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),e0("EmbeddedWalletConnectingScreen")}),sendTransaction:async(e,t)=>await ti({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await ti({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),promptMfa:ts,async init(e){switch(e){case"sms":return void await t.initMfaSmsVerification();case"passkey":return await t.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new k.a("Invalid MFA code");eD.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise((e,t)=>{eH.current={resolve:e,reject:t}});break;case"passkey":let r;if("string"==typeof t)throw new k.a("Invalid authenticator response");let a=await n.e(4665).then(n.bind(n,54665)),i={id:(r=await a.startAuthentication({optionsJSON:t})).id,raw_id:r.rawId,response:{client_data_json:r.response.clientDataJSON,authenticator_data:r.response.authenticatorData,signature:r.response.signature,user_handle:r.response.userHandle},authenticator_attachment:r.authenticatorAttachment,client_extension_results:{app_id:r.clientExtensionResults.appid,cred_props:r.clientExtensionResults.credProps,hmac_create_secret:r.clientExtensionResults.hmacCreateSecret},type:r.type};eD.current?.resolve({mfaMethod:e,mfaCode:i,relyingParty:window.origin}),await new Promise((e,t)=>{eH.current={resolve:e,reject:t}});break;default:throw eD.current?.reject(new k.a("Unsupported MFA method")),new k.a(`Unsupported MFA method: ${e}`)}},cancel(){eD.current?.reject(new k.a("MFA canceled"))},async initEnrollmentWithSms(e){let t=await es();if(!t||!eu)throw Error("Must have valid access token to enroll in MFA");await eu.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise((t,n)=>{e?(d.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),eC({mfaEnrollmentFlow:{mfaMethods:d.mfa.methods,shouldUnlinkOnUnenrollMfa:d.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:n}}),e0("MfaEnrollmentFlowScreen")):(tp.closePrivyModal(),t())}),async initEnrollmentWithTotp(){let e=await es();if(!e||!eu)throw Error("Must have valid access token to enroll in MFA");let t=await eu.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let n=await es();if(!n||!eu)throw Error("Must have valid access token to enroll in MFA");await eu.submitEnrollMfa({method:"sms",accessToken:n,phoneNumber:e.phoneNumber,code:e.mfaCode}),b(await t.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let n=await es();if(!n||!eu)throw Error("Must have valid access token to enroll in MFA");await eu.submitEnrollMfa({method:"totp",accessToken:n,code:e.mfaCode}),b(await t.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},n={}){let r=await es();if(!r||!eu)throw Error("Must have valid access token to enroll in MFA");await eu.submitEnrollMfa({method:"passkey",accessToken:r,credentialIds:e,removeForLogin:n.removeForLogin}),b(await t.getAuthenticatedUser())},async unenroll(e,n={}){let r=await es();if(!r||!eu)throw Error("Must have valid access token to remove MFA");"passkey"===e?await eu.submitEnrollMfa({method:"passkey",accessToken:r,credentialIds:[],removeForLogin:n.removeForLogin}):await eu.unenrollMfa({method:e,accessToken:r}),b(await t.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await es(),n=v?.linkedAccounts.find(e=>"wallet"===e.type&&"privy"===e.walletClientType);if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!eu||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if((0,A.b)(n))throw new k.a("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!v?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await tp.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");let r=await eu.initFarcasterSigner({address:n.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&b(await t.getAuthenticatedUser()||v||null),eC({farcasterSigner:r}),e0("FarcasterSignerStatusScreen")},getFarcasterSignerPublicKey:async()=>{let e,t=await es(),n=v?.linkedAccounts.find(e=>"wallet"===e.type&&"privy"===e.walletClientType);if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!eu||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if((0,A.b)(n))throw new k.a("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!v?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await tp.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!v.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=v.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map(e=>parseInt(e,16)))},signFarcasterMessage:async e=>{let t=await es(),r=v?.linkedAccounts.find(e=>"wallet"===e.type&&"privy"===e.walletClientType);if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!eu||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if((0,A.b)(r))throw new k.a("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!v?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await tp.recoverEmbeddedWallet({address:r.address}))throw Error("Unable to connect to wallet");if(!v.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let a=await n.e(4665).then(n.bind(n,54665)),i=await eu.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:a.bufferToBase64URLString(e)},fid:BigInt(v.farcaster.fid),relyingParty:window.origin});return new Uint8Array(a.base64URLStringToBuffer(i.signature))},signMessageWithCrossAppWallet(e,{address:n,chainId:r}){let a=v?.linkedAccounts.some(e=>"cross_app"===e.type&&e.smartWallets.some(e=>e.address===n));return tb({user:v,client:t,address:n,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,n],chainId:r},reconnect:td})},signTypedDataWithCrossAppWallet(e,{address:n,chainId:r}){let a=v?.linkedAccounts.some(e=>"cross_app"===e.type&&e.smartWallets.some(e=>e.address===n)),i=(0,C.j)(e);return tb({user:v,client:t,address:n,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[n,i],chainId:r},reconnect:td})},sendTransactionWithCrossAppWallet(e,{address:n}){let r=v?.linkedAccounts.some(e=>"cross_app"===e.type&&e.smartWallets.some(e=>e.address===n));return tb({user:v,client:t,address:n,requesterAppId:d.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:td})},signTransactionWithCrossAppWallet(e,{address:n}){let r=v?.linkedAccounts.some(e=>"cross_app"===e.type&&e.smartWallets.some(e=>e.address===n));return tb({user:v,client:t,address:n,requesterAppId:d.id,request:{method:r?"privy_signSmartWalletTx":"eth_signTransaction",params:[e],chainId:e.chainId},reconnect:td})},isModalOpen:u||!!y,mfaMethods:d.mfa.methods};i=tu.signMessage,s=tu.signTypedData,l=async(e,t)=>await ti({transaction:e,...t,signOnly:!1}),o=async(e,t)=>({signature:(await ti({transaction:e,...t,signOnly:!0})).hash});let th=async e=>{let n,r,a;B(!0),ei({status:"loading"}),t.startAuthFlow(new eb({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl}));let i=T.s.get(I.S),s=e.stateCode;if(i!==s)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:i??"",returnedStateCode:s??""}}),B(!1),new k.a("Unexpected auth flow. This may be a phishing attempt.",void 0,k.b.OAUTH_UNEXPECTED);if(null!==await t.getAccessToken())try{({user:n,oAuthTokens:a}=await t.link()),eJ.current=e.provider;let r=to(n);n&&r&&(0,L.e)(eB,"linkAccount","onSuccess",{user:n,linkMethod:eJ.current,linkedAccount:r})}catch(t){throw B(!1),(0,L.e)(eB,"linkAccount","onError",t.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:n,isNewUser:r,oAuthTokens:a}=await t.authenticate()),eJ.current=e.provider;let i=to(n);n&&i&&void 0!==r&&(0,L.e)(eB,"login","onComplete",{user:n,isNewUser:r,wasAlreadyAuthenticated:!1,loginMethod:eJ.current,loginAccount:i})}catch(e){throw B(!1),ei({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}return b(n),j(r||!1),eY(!0),B(!1),ei({status:"done"}),a&&n&&(0,L.e)(eB,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:n}),n??void 0},tp={privy:r,setAuthenticated:eY,setUser:b,setIsNewUser:j,isNewUserThisSession:D,pendingTransaction:null,walletConnectionStatus:G,setWalletConnectionStatus:Y,connectors:t.connectors?.walletConnectors??[],rpcConfig:d.rpcConfig,chains:d.chains,appId:e.appId,showFiatPrices:"native-token"!==d.embeddedWallets.priceDisplay.primary,clientAnalyticsId:t.clientAnalyticsId,hideWalletUIs:eZ,isHeadlessSigning:(0,p.useCallback)(eX,[d.embeddedWallets.showWalletUIs]),emailOtpState:Z,setEmailOtpState:X,smsOtpState:ee,setSmsOtpState:et,oAuthState:ea,setOAuthState:ei,telegramAuthState:eo,setTelegramAuthState:el,siweState:en,setSiweState:er,isHeadlessOAuthLoading:H,baseAccountSdk:S,setBaseAccountSdk:F,nativeTokenSymbolForChainId:e=>d.chains.find(t=>t.id===Number(e))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(eu)return eu;let t=new Promise(e=>{ex.current=e}),n=new Promise(t=>setTimeout(()=>t(null),e)),r=await Promise.race([t,n]);return ex.current=null,r},getAuthFlow:()=>t.authFlow,getAuthMeta:()=>t.authFlow?.meta,client:t,closePrivyModal:async(n={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let r,i=g&&e$&&v;if(i&&eJ.current&&(r=to(v)),"login"===eQ.current)n.shouldCallAuthOnSuccess&&i&&eJ.current?(0,L.e)(eB,"login","onComplete",{user:v,isNewUser:D,wasAlreadyAuthenticated:!1,loginMethod:eJ.current,loginAccount:r??null}):(0,L.e)(eB,"login","onError",k.b.USER_EXITED_AUTH_FLOW);else if("link"===eQ.current&&r)n.isSuccess&&i&&eJ.current?(0,L.e)(eB,"linkAccount","onSuccess",{user:v,linkMethod:eJ.current,linkedAccount:r}):eJ.current&&(0,L.e)(eB,"linkAccount","onError",k.b.USER_EXITED_LINK_FLOW,{linkMethod:eJ.current});else if("update"===eQ.current&&r)n.isSuccess&&i&&eJ.current?(0,L.e)(eB,"update","onSuccess",{user:v,updateMethod:eJ.current,updatedAccount:r}):eJ.current&&(0,L.e)(eB,"update","onError",k.b.USER_EXITED_UPDATE_FLOW,{linkMethod:eJ.current});else if("connect-or-create"===eQ.current){let e=tM.getState().ethereum;e[0]?(0,L.e)(eB,"connectOrCreateWallet","onSuccess",{wallet:e[0]}):(0,L.e)(eB,"connectOrCreateWallet","onError",k.b.USER_EXITED_AUTH_FLOW)}let s=z&&tP.has(z),o="ErrorScreen"===z&&eg.errorModalData&&tP.has(eg.errorModalData.previousScreen);if((s||o)&&eg.funding){let t,n=tP.get(z)??null;if(o&&eg.funding?.onError){let e=eg.errorModalData?.error,t=e?.privyErrorCode||k.b.UNKNOWN_FUNDING_ERROR,n=new k.a(e?.message||"Funding failed",e,t);eg.funding?.onError?.(n)}if("solana"===eg.funding.chainType){let e=d.solanaRpcs[eg.funding.chain];if(!e)return console.warn("Unable to load solana rpc, skipping balance"),(0,L.e)(eB,"fundSolanaWallet","onUserExited",{address:eg.funding.address,fundingMethod:n,chain:eg.funding.chain,balance:t}),w(!1),void tS(eg.funding,n);if(a(M.S))try{t=await tU({rpc:e.rpc,address:eg.funding.address})}catch{console.error("Unable to pull wallet balance")}else console.warn("Unable to load solana plugin, skipping balance");(0,L.e)(eB,"fundSolanaWallet","onUserExited",{address:eg.funding.address,fundingMethod:n,chain:eg.funding.chain,balance:t})}else{let r=(0,$.g)(eg.funding.chain.id,d.chains,d.rpcConfig,{appId:e.appId});try{t=await r.getBalance({address:eg.funding.address})}catch{console.error("Unable to pull wallet balance")}(0,L.e)(eB,"fundWallet","onUserExited",{address:eg.funding.address,chain:eg.funding.chain,fundingMethod:n,balance:t}),tS(eg.funding,n)}}eC(e=>({...e,externalConnectWallet:{}})),eQ.current=null,eJ.current=null,j(!1),w(!1),Y({status:"disconnected",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout(()=>{t.authFlow=void 0},200)},openPrivyModal:e0,connectWallet:e8,initLoginWithWallet:async(e,t,n,r)=>{(0,C.f)(e)?(eJ.current="siwe",e9(e,t,n)):(eJ.current="siws",te(e,t,n,r))},loginWithWallet:async()=>{let e,n,r;if(!g)throw new k.g;if(t.authFlow instanceof eT?e="siwe":t.authFlow instanceof eE&&(e="siws"),!e)throw new k.a("Must initialize SIWE/SIWS flow first.");if(null!==await t.getAccessToken())try{({user:n}=await t.link()),eJ.current=e}catch(t){throw(0,L.e)(eB,"linkAccount","onError",t.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:n,isNewUser:r}=await t.authenticate()),eJ.current=e}catch(e){throw(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.GENERIC_CONNECT_WALLET_ERROR),e}b(n||v||null),j(r||!1),eY(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:n})=>new Promise(async(r,a)=>{let i=await es();if(!e$||!v||!i)throw new k.a("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new k.a("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let s=tp.walletProxy??await tp.initializeWalletProxy(15e3);if(!s)throw new k.a("Wallet proxy not initialized.");if((({address:e,user:t})=>!!ty(t).find(t=>t.address===e))({address:e,user:v}))return r();let o=(0,A.h)(v,e);if(!o)throw new k.a("Address to delegate is not associated with current user.");if((0,A.b)(o))throw new k.a("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let l=(({address:e,user:t})=>{let n=t.linkedAccounts.find(t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e);if(!n)throw new k.a("Address to delegate is not associated with current user.");if(!(0,T.i)(n))throw new k.a(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,walletIndex:n.walletIndex??0}})({address:e,user:v}),c=(({address:e,user:t})=>{let n=t.linkedAccounts.find(t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e);if(!n)throw new k.a("Address to delegate is not associated with current user.");let r=n.imported?n:(0,A.g)(t);if(!r)throw new k.a("Unable to determine root address for delegated address.");if(!(0,T.i)(r))throw new k.a(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,imported:r.imported}})({address:e,user:v}),d=async()=>{await s.createDelegatedAction({accessToken:i,rootWallet:c,delegatedWallets:[l]}),await tp.refreshSessionAndUser()};if(await tp.recoverEmbeddedWallet({address:e}),n)eC({delegatedActions:{consent:{address:e,onDelegate:d,onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),e0("DelegatedActionsConsentScreen");else try{await d(),r()}catch(e){a(e)}}),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise(async(n,r)=>{if(!e$||!v)throw new k.a("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");let a=ty(v);if(0===a.length)throw new k.a("User has no delegated wallets to revoke.");if(a.some(A.b))throw new k.a("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let i=async()=>{await t.revokeDelegatedWallet(),await tp.refreshSessionAndUser()};if(e)eC({delegatedActions:{revoke:{onRevoke:i,onSuccess:async()=>{n()},onError:async e=>{r(e)}}}}),e0("DelegatedActionsRevokeScreen");else try{await i(),n()}catch(e){r(e)}}),initLoginWithFarcaster:async(e,n)=>{let r=new eh(e,n);t.startAuthFlow(r);try{eJ.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===eQ.current?(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR):"link"===eQ.current&&(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,n;if(!g)throw new k.g;if(!(t.authFlow instanceof eh))throw new k.a("Must initialize Farcaster flow first.");if(null!==await t.getAccessToken())try{({user:e}=await t.link()),eJ.current="farcaster"}catch(e){throw(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:n}=await t.authenticate()),eJ.current="farcaster"}catch(e){throw(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}b(e||null),j(n||!1),eY(!0)},async crossAppAuthFlow({appId:e,popup:n,action:r,disableSignup:a}){let i=`privy:${e}`;eJ.current=i;let{url:s,stateCode:o,codeVerifier:l}=await async function({api:e,appId:t}){let n=ef(),r=ev(),a=await eA(n);try{let{url:i}=await e.post(R.h,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:a,state_code:r});return{url:i,stateCode:r,codeVerifier:n}}catch(e){throw(0,k.f)(e)}}({api:t.api,appId:e});if(!s)throw t.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new k.a("No authorization URL returned for cross-app auth.");try{let c=await async function({url:e,popup:t}){return t.location=e,new Promise((e,n)=>{let r,a=setTimeout(()=>{n(new k.a("Authorization request timed out after 2 minutes.")),i()},12e4);function i(){t?.close(),window.removeEventListener("message",o)}let s=setInterval(()=>{t?.closed&&!r&&(i(),clearInterval(s),clearTimeout(a),n(new k.a("User rejected request")))},300);function o(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(a),e(t.data),i()),"PRIVY_OAUTH_ERROR"===t.data.type&&(clearTimeout(a),n(new k.a(t.data.error)),i()),t.data.type===tf&&((r=new BroadcastChannel(tg)).onmessage=o))}window.addEventListener("message",o)})}({url:s,popup:n,provider:i}),d=c.stateCode,u=c.authorizationCode;if(d!==o)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:i,storedStateCode:o??"",returnedStateCode:d??""}}),new k.a("Unexpected auth flow. This may be a phishing attempt.",void 0,k.b.OAUTH_UNEXPECTED);let h=await async function({appId:e,stateCode:t,codeVerifier:n,authorizationCode:r,action:a,client:i,disableSignup:s}){if(!r||!t)throw new k.a("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===r)throw new k.a("User denied confirmation during cross-app auth flow");try{let o=new tv({authorizationCode:r,stateCode:t,codeVerifier:n,provider:`privy:${e}`,disableSignup:!!s});i.startAuthFlow(o);let l="link"===a?await i.link():await i.authenticate(),c=l.oAuthTokens?.accessToken;return console.debug(),c}catch(t){let e=(0,k.f)(t);if(e.privyErrorCode===k.b.ACCOUNT_TRANSFER_REQUIRED)throw e;if(e.privyErrorCode)throw new k.a(e.message||"Invalid code during cross-app auth flow.",void 0,e.privyErrorCode);if("User denied confirmation during cross-app auth flow"===e.message)throw new k.a("Invalid code during cross-app auth flow.",void 0,k.b.OAUTH_USER_DENIED);throw new k.a("Invalid code during cross-app auth flow.",void 0,k.b.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:l,stateCode:d,authorizationCode:u,action:r,client:t,disableSignup:a});h&&t.storeProviderAccessToken(e,h);let p=await tp.refreshSessionAndUser();if(!p)throw new k.a("Unable to update user");return t.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),p}catch(e){throw t.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:i}}),e}},async initLoginWithOAuth(e,n,r){if(eJ.current=e,!(0,T.b)()||"google"===e&&!d.allowOAuthInEmbeddedBrowsers&&tW(window.navigator.userAgent))return void e0("InAppBrowserLoginNotPossible");"twitter"===e&&window.opener&&window.opener.postMessage({type:tf},"*"),T.s.del(I.H),T.s.del(I.O);let a=new eb({provider:e,disableSignup:!!r,withPrivyUi:!0,customOAuthRedirectUrl:d.customOAuthRedirectUrl});n&&a.addCaptchaToken(n),t.startAuthFlow(a);let i=await t.authFlow.getAuthorizationUrl();if(i&&i.url)if("twitter"===e&&W.m0&&(i.url=i.url.replace("x.com","twitter.com")),"chrome-extension:"===window.location.protocol&&em())try{let{privyOAuthCode:e,privyOAuthState:t}=await ey(i.url);e0("OAuthStatusScreen"),a.meta.stateCode=t,a.meta.authorizationCode=e}catch(e){throw console.error("OAuth in chrome extension flow failed:",e),e}else window.location.assign(i.url)},async initLoginWithTelegram(e,n){if(!g)throw new k.g;eJ.current="telegram";let r=new eO(e,n);t.startAuthFlow(r),el({status:"loading"}),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise((e,t)=>d.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:d.loginConfig.telegramAuthConfiguration.botId,request_access:!0},n=>n?e(n):("link"===eQ.current?(0,L.e)(eB,"linkAccount","onError",k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}):"login"===eQ.current?(0,L.e)(eB,"login","onError",k.b.INVALID_CREDENTIALS):"update"===eQ.current&&(0,L.e)(eB,"login","onError",k.b.FAILED_TO_UPDATE_ACCOUNT),t(new k.a("Telegram auth failed or was canceled by the client")))):t(new k.a("Telegram was not initialized")):t(new k.a("Telegram Auth configuration is not loaded")))},async loginWithTelegram(e){let n,r;if(!(t.authFlow instanceof eO))throw new k.a("Must initialize Telegram flow before calling loginWithTelegram");t.authFlow.meta.captchaToken||=e?.captchaToken;let a=await es(),i=e?.intent||eQ.current;if("login"===i)try{let e=await t.authenticate();n=e.user,r=e.isNewUser,eJ.current="telegram"}catch(e){throw(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}else{if("link"!==i)throw new k.a("Unknown auth intent");try{n=(await t.link()).user,eJ.current="telegram"}catch(e){throw(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}b(n),j(r||!1),eY(!0),el({status:"done"});let s=n?.linkedAccounts.find(({type:e})=>"telegram"===e)||null;return{user:n,isNewUser:r||!1,wasAlreadyAuthenticated:!!a,loginAccount:s}},async loginWithOAuth(e){let n,r,a;if(!(t.authFlow instanceof eb))throw new k.a("Must initialize OAuth flow before calling loginWithOAuth");let i=T.s.get(I.S),s=t.authFlow.meta.stateCode;if(i!==s)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:i??"",returnedStateCode:s??""}}),new k.a("Unexpected auth flow. This may be a phishing attempt.",void 0,k.b.OAUTH_UNEXPECTED);if(null!==await t.getAccessToken())try{let r=await t.link();n=r.user,a=r.oAuthTokens,eJ.current=e}catch(t){throw(0,L.e)(eB,"linkAccount","onError",t.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let i=await t.authenticate();n=i.user,r=i.isNewUser,a=i.oAuthTokens,eJ.current=e}catch(t){throw"login"===eQ.current?(0,L.e)(eB,"login","onError",t.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR):"link"===eQ.current&&(0,L.e)(eB,"linkAccount","onError",t.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return b(n),j(r||!1),eY(!0),a&&n&&(0,L.e)(eB,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:n}),a},passkeyAuthState:J,setPasskeyAuthState:Q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:n}){let r=new e_({captchaToken:e,setPasskeyAuthState:Q,hints:d.passkeys.registration?.hints});t.startAuthFlow(r),eQ.current="login";try{eJ.current="passkey",Q({status:"generating-challenge"}),await r.initRegisterFlow(n),Q({status:"awaiting-passkey"})}catch(e){throw Q({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,n;if(!g)throw new k.g;if(!(t.authFlow instanceof e_))throw new k.a("Must initialize Passkey flow first.");if("passkey"!==eJ.current){let e=new k.a("Must init login with Passkey flow first.");throw Q({status:"error",error:e}),e}let r=await es();try{eJ.current="passkey",Q({status:"awaiting-passkey"}),{user:e,isNewUser:n}=await t.authenticate()}catch(e){throw Q({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}b(e),j(n||!1),eY(!0),Q({status:"done"});let a=e?.linkedAccounts.find(({type:e})=>"passkey"===e)||null;return{user:e,isNewUser:n||!1,wasAlreadyAuthenticated:!!r,loginAccount:a}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:n}){let r=new e_({captchaToken:e,setPasskeyAuthState:Q,hints:void 0});t.startAuthFlow(r),eQ.current="login";try{eJ.current="passkey",Q({status:"generating-challenge"}),await r.initAuthenticationFlow(n),Q({status:"awaiting-passkey"})}catch(e){throw Q({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let n,r;if(!g)throw new k.g;if(!(t.authFlow instanceof e_))throw new k.a("Must initialize Passkey flow first.");if(e?.credentialIds&&(t.authFlow.meta.allowedCredentialsIds=e.credentialIds),"passkey"!==eJ.current){let e=new k.a("Must init login with Passkey flow first.");throw Q({status:"error",error:e}),e}let a=await es();try{eJ.current="passkey",Q({status:"awaiting-passkey"}),{user:n,isNewUser:r}=await t.authenticate()}catch(e){throw Q({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}b(n),j(r||!1),eY(!0),Q({status:"done"});let i=n?.linkedAccounts.find(({type:e})=>"passkey"===e)||null;return{user:n,isNewUser:r||!1,wasAlreadyAuthenticated:!!a,loginAccount:i}},async initLinkWithPasskey(e){let n=new e_({captchaToken:e,hints:d.passkeys.registration?.hints});t.startAuthFlow(n),eQ.current="link",eJ.current="passkey",Q({status:"generating-challenge"});try{await n.initLinkFlow(),Q({status:"awaiting-passkey"})}catch(e){throw(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),Q({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!g)throw new k.g;if(!(t.authFlow instanceof e_))throw new k.a("Must initialize Passkey flow first.");if("passkey"!==eJ.current)throw new k.a("Must init login with Passkey flow first.");try{eJ.current="passkey",{user:e}=await t.link()}catch(e){throw(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return b(e||v||null),Q({status:"done"}),e},async initLoginWithHeadlessOAuth(e,n,r){if(!(0,T.b)()||"google"===e&&!d.allowOAuthInEmbeddedBrowsers&&tW(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new eb({provider:e,withPrivyUi:!1,disableSignup:r??!1,customOAuthRedirectUrl:d.customOAuthRedirectUrl});n&&a.addCaptchaToken(n),ei({status:"loading"});let i=await t.startAuthFlow(a).getAuthorizationUrl();if(i?.url)if("chrome-extension:"===window.location.protocol&&em())try{let{privyOAuthCode:e,privyOAuthState:t}=await ey(i.url);a.meta.stateCode=t,a.meta.authorizationCode=e,await th(a.meta)}catch(e){throw ei({status:"error",error:e}),e}else window.location.assign(i.url)},loginWithHeadlessOAuth:th,initLoginWithEmail:async({email:e,captchaToken:n,disableSignup:r,withPrivyUi:a})=>{let i=new ec({email:e,captchaToken:n,disableSignup:r});t.startAuthFlow(i);try{eJ.current="email",X({status:"sending-code"});let e=await i.sendCodeEmail({withPrivyUi:a});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await (0,C.k)(1e4);X({status:"awaiting-code-input"})}catch(e){throw X({status:"error",error:e}),"login"===eQ.current?(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR):"link"===eQ.current&&(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:n,captchaToken:r})=>{let a=new ed(e,n,r);t.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){throw(0,L.e)(eB,"update","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR,{linkMethod:eJ.current}),e}},initUpdatePhone:async(e,n,r)=>{let a=new eI(e,n,r);t.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){(0,L.e)(eB,"update","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR,{linkMethod:eJ.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:n,disableSignup:r,withPrivyUi:a})=>{et({status:"sending-code"});let i=new eS({phoneNumber:e,captchaToken:n,disableSignup:r});t.startAuthFlow(i);try{eJ.current="sms",await i.sendSmsCode({withPrivyUi:a}),et({status:"awaiting-code-input"})}catch(e){throw et({status:"error",error:e}),"login"===eQ.current?(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR):"link"===eQ.current&&(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await t.authFlow?.sendCodeEmail({withPrivyUi:!0})},resendSmsCode:async()=>{await t.authFlow?.sendSmsCode({withPrivyUi:!0})},loginWithCode:async e=>{let n,r;function a(e){t.authFlow instanceof ec?X(e):t.authFlow instanceof eS&&et(e)}if(a({status:"submitting-code"}),!g){let e=new k.g;throw a({status:"error",error:e}),e}if(t.authFlow instanceof ec)t.authFlow.meta.emailCode=e.trim();else{if(!(t.authFlow instanceof eS)){let e=new k.a("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}t.authFlow.meta.smsCode=e.trim()}let i=await es();if("link"===eQ.current)try{({user:n}=await t.link())}catch(e){throw a({status:"error",error:e}),(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:eJ.current}),e}else if("update"===eQ.current)try{({user:n}=await t.link())}catch(e){throw a({status:"error",error:e}),(0,L.e)(eB,"update","onError",e.privyErrorCode||k.b.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:eJ.current}),e}else try{({user:n,isNewUser:r}=await t.authenticate())}catch(e){throw a({status:"error",error:e}),(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),e}let s=n||v;b(s||null),j(r||!1),eY(!0),a({status:"done"});let o=null;return t.authFlow instanceof ec?o=s?.linkedAccounts.find(({type:e})=>"email"===e)||null:t.authFlow instanceof eS&&(o=s?.linkedAccounts.find(({type:e})=>"phone"===e)||null),{user:s,isNewUser:r||!1,wasAlreadyAuthenticated:!!i,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:n,captchaToken:r})=>{eQ.current=e$?"link":"login",eJ.current="siwe",er({status:"generating-message"});let a=await t.generateSiweNonce({address:e,captchaToken:r});return er({status:"awaiting-signature"}),ek({address:e,chainId:n.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:n})=>{let r=await t.generateSiweNonce({address:e});return ek({address:e,chainId:n.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:n,smartWalletType:r,smartWalletVersion:a})=>{let i;i=await t.linkSmartWallet({message:e,signature:n,smartWalletType:r,smartWalletVersion:a}),b((i=await tp.refreshSessionAndUser()??i)||v||null)},loginWithSiwe:async({message:e,signature:n,captchaToken:r,disableSignup:a,walletClientType:i,connectorType:s})=>{let o,l=null;try{if(v)throw Error("User already authenticated");let c=new eT(t,void 0,r,a,{message:e,signature:n,walletClientType:i,connectorType:s});t.startAuthFlow(c),eJ.current="siwe",eQ.current="login",er({status:"submitting-signature"});let d=await t.authenticate();if({user:l,isNewUser:o}=d,!l)throw Error("Authentication failed - no user returned")}catch(e){throw(0,L.e)(eB,"login","onError",e.privyErrorCode||k.b.UNKNOWN_AUTH_ERROR),er({status:"error",error:e}),e}return b(l),j(o||!1),eY(!0),er({status:"done"}),eQ.current=null,eJ.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:n,chainId:r,walletClientType:a,connectorType:i})=>{let s;tr("siwe");let o=null;try{er({status:"submitting-signature"}),s=await t.linkWithSiwe({message:e,signature:n,chainId:r,walletClientType:a,connectorType:i}),s=await tp.refreshSessionAndUser()??s,er({status:"done"}),(o=to(s)||null)&&(0,L.e)(eB,"linkAccount","onSuccess",{user:s,linkMethod:"siwe",linkedAccount:o})}catch(e){throw(0,L.e)(eB,"linkAccount","onError",e.privyErrorCode||k.b.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),eQ.current=null,eJ.current=null,er({status:"error",error:e}),e}let l=s||v;return b(l||null),eQ.current=null,eJ.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await t.getAuthenticatedUser();return eY(!!e),b(e),e},walletProxy:eu,createAnalyticsEvent:({eventName:e,payload:n,timestamp:r})=>t.createAnalyticsEvent({eventName:e,payload:n,timestamp:r}),acceptTerms:async()=>{let e=await t.acceptTerms();return b(e),e},getUsdTokenPrice:e=>t.getUsdTokenPrice(e),getUsdPriceForSol:()=>t.getUsdPriceForSol(),getSplTokenMetadata:e=>t.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise(async(n,r)=>{if(!v)return void n(!0);let a=e?.address?(0,A.h)(v,e.address):(0,A.g)(v)||(0,A.f)(v).at(0)||(0,A.k)(v).at(0);if(!a||(0,A.b)(a))return void n(!0);let i=await es();if(!i||!eu||!a)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));let{entropyId:s,entropyIdVerifier:o}=(0,_.g)(v,a);try{await eu.connect({accessToken:i,entropyId:s,entropyIdVerifier:o}),n(!0)}catch(e){if(tt(e)&&"privy"===a.recoveryMethod){let e;t.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}});try{e=await eu.recover({entropyId:s,entropyIdVerifier:o,accessToken:i})}catch(e){return void r(e)}e.entropyId||r(Error("Unable to recover wallet")),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),n(!0)}else tt(e)&&"privy"!==a.recoveryMethod&&"privy-v2"!==a.recoveryMethod?(eC({recoverWallet:{entropyId:s,entropyIdVerifier:o,onFailure:r,onSuccess:()=>n(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover",shouldCreateEth:!1,shouldCreateSol:!1}}),e0(tE(a.recoveryMethod))):r(e)}}),setReadyToTrue:e=>{f(!0),eP?.(e)},updateWallets:()=>ta(),fundWallet:async(e,t)=>{let n="FundingMethodSelectionScreen";return new Promise((r,a)=>{eC({funding:{...(0,T.p)({address:e,appConfig:d,fundWalletConfig:t,methodScreen:n,onComplete:r,onError:a})}}),e0(n)})},openModal:e0,requestFarcasterSignerStatus:async e=>{let n=await es(),r=v?.linkedAccounts.find(e=>"wallet"===e.type&&"privy"===e.walletClientType);if(!n)throw Error("Must have valid access token to connect with Farcaster");if(!eu||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!v?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await t.requestFarcasterSignerStatus(e);return"approved"===a.status&&b(await t.getAuthenticatedUser()||v||null),a},connectCoinbaseSmartWallet:async()=>{d.externalWallets.coinbaseWallet.config.preference={...d.externalWallets.coinbaseWallet.config.preference,options:"smartWalletOnly"};let e=t.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||t.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),e8(e);await e5("coinbase_wallet","coinbase_smart_wallet")},connectBaseAccount:async()=>{let e=t.connectors?.findWalletConnector("base_account","base_account");if(e)return e8(e);await e5("base_account","base_account")},initiateAccountTransfer:async({nonce:e,account:n,accountType:r,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await t.sendAccountTransferRequest({nonce:e,account:n,accountType:r,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return b(c),c},inProgressAuthFlowRef:eQ,inProgressLoginOrLinkMethodRef:eJ};c=tp.recoverEmbeddedWallet,tp.recoverEmbeddedWallet;let tw=(0,p.useMemo)(()=>({wallets:E,ready:eN&&eV}),[E,eN,eV]),tC=t.authFlow instanceof eO,{siteKey:t_,enabledProvider:tk}=d.captcha,tI=!d.headless&&tk&&!e$&&(g||tC);return(0,h.jsx)(tV.Provider,{value:!0,children:(0,h.jsx)(A.P.Provider,{value:tu,children:(0,h.jsx)(L.P.Provider,{value:eB,children:(0,h.jsx)(_.U.Provider,{value:tw,children:(0,h.jsx)(eU,{appId:d.id,captchaSiteKey:t_,enabledCaptchaProvider:tk,children:(0,h.jsxs)(k.I.Provider,{value:tp,children:[(0,h.jsx)(C.R,{children:(0,h.jsxs)(A.M,{data:eg,setModalData:eC,setInitialScreen:q,initialScreen:z,authenticated:e$,open:u,children:[e.children,(0,h.jsx)(tB,{customAuth:d.customAuth}),tI&&(0,h.jsx)(eL,{delayedExecution:!1}),(0,h.jsx)(e6,{}),(0,h.jsx)(tR,{disabled:d.embeddedWallets.disableAutomaticMigration}),(0,h.jsx)(eq,{palette:d.appearance.palette||{}}),!d.render.standalone&&(0,h.jsx)(e1,{open:u})]})}),(0,h.jsx)(tm,{appId:e.appId,appClientId:e.clientId,clientAnalyticsId:t.clientAnalyticsId,origin:t.apiUrl,mfaMethods:v?.mfaMethods,mfaPromise:eD,mfaSubmitPromise:eH,onLoad:ep,onLoadFailed:()=>null}),d.loginConfig.telegramAuthConfiguration&&(0,h.jsx)(C.H,{$if:!0,children:(0,h.jsx)(e3,{scriptHost:e.apiUrl||I.D,botUsername:d.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})};class t$ extends Error{constructor(e,t,n){super(e),this.code=t,this.data=n}}class tG extends b.A{async handleSendTransaction(e){let t;if(!e.params||!Array.isArray(e.params))throw new t$(`Invalid params for ${e.method}`,4200);let n=e.params[0];if(!await es()||!this.address)throw new t$("Disconnected",4900);let{hash:r}=await (t={address:this.address},l(n,t));return r}async handleSignTransaction(e){let t;if(!e.params||!Array.isArray(e.params))throw new t$(`Invalid params for ${e.method}`,4200);let n=e.params[0];if(!await es()||!this.address)throw new t$("Disconnected",4900);let{signature:r}=await (t={address:this.address},o(n,t));return r}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new t$(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new t$(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=(0,$.g)(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],n=e.params[1],{signature:r}=await i({message:t},{address:n});return r}async handleSignedTypedData(e){let t;if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let n=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:a}=await (t=(0,C.j)(r),s(t,{address:n}));return a}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:(0,C.t)(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...(0,S._)(t)})}async request(e){let t;switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return(0,C.t)(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(t=e.method,!eo.includes(t))return this.publicClient.request({method:e.method,params:e.params});{let t,n=await es();if(await (t={address:this.address},c(t)),!n||!this.address)throw new t$("Disconnected",4900);try{let t={method:e.method,params:e.params},r=this.walletAccount;return r&&(0,A.b)(r)?this.handleWalletApiRequest(t,r,n):(await this.walletProxy.rpc({accessToken:n,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:t})).response.data}catch(e){throw console.error(e),new t$("Disconnected",4900)}}}async handleWalletApiRequest(e,t,n){let r=this.privyClient;if(!r)throw new t$("Disconnected",4900);if("secp256k1_sign"===e.method){let a=await (0,m._)(r,async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e}),{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:e.params[0]}});if("secp256k1_sign"!==a.method)throw new t$(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new t$(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:n,entropyIdVerifier:r,rpcConfig:a,chains:i,appId:s,chainId:o=1,walletIndex:l,privyClient:c,walletAccount:d}){super(),this.walletProxy=e,this.address=t,this.entropyId=n,this.entropyIdVerifier=r,this.chainId=o,this.rpcConfig=a,this.chains=i,this.publicClient=(0,$.g)(o,this.chains,a,{appId:s}),this.rpcTimeoutDuration=(0,C.c)(a,"privy"),this.appId=s,this.walletIndex=l,this.privyClient=c,this.walletAccount=d}}let tY=({style:e,...t})=>(0,h.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",stroke:"currentColor",strokeWidth:1.5,viewBox:"0 0 24 24",style:{...e},...t,children:(0,h.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"})}),tJ=({style:e,...t})=>(0,h.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"108",height:"108",viewBox:"0 0 108 108",fill:"none",style:{height:"28px",width:"28px",...e},...t,children:[(0,h.jsx)("rect",{width:"108",height:"108",rx:"23",fill:"#AB9FF2"}),(0,h.jsx)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",fill:"#FFFDF8"})]});function tQ(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var tZ=0;class tX extends C.E{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new k.P("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw(0,T.f)(e)}}constructor(e,t,n,r,a){super(a||"unknown",e,t,n),this.connectorType="injected",this.proxyProvider=new C.P(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=r;let i=r.provider;this.proxyProvider.setWalletProvider(i)}}var t0="__private_"+tZ+++"__walletBranding";class t1 extends C.E{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return tQ(this,t0)[t0]??{name:"Browser Extension",icon:tY,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new k.P("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw(0,T.f)(e)}}constructor(e,t,n,r,a){super(a??"unknown",e,t,n),Object.defineProperty(this,t0,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new C.P(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(r),"metamask"===a?tQ(this,t0)[t0]={name:"MetaMask",icon:C.M,id:"io.metamask"}:"phantom"===a&&(tQ(this,t0)[t0]={name:"Phantom",icon:tJ,id:"phantom"})}}class t2 extends tX{disconnect(){console.warn("MetaMask does not support programmatic disconnect.")}async promptConnection(){try{W.Fr||await this.proxyProvider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new k.P("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw(0,T.f)(e)}}}class t4 extends b.A{get wallets(){let e=new Set;return this.walletConnectors.flatMap(e=>e.wallets).sort((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0).filter(t=>{let n=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(n)&&(e.add(n),!0)})}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=(0,C.o)({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then(e=>{e.forEach(({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:n})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:n}})})});for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),this.walletList.includes("base_account")&&this.createEthereumWalletConnector({connectorType:"base_account",walletClientType:"base_account"}),Object.values(C.q)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addSolanaWalletConnector(new C.S({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes("wallet_connect_qr")||(0,C.e)(this.walletList))&&"solana-only"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"});let n=this.walletList.includes("wallet_connect_qr_solana")||(0,C.e)(this.walletList)&&"ethereum-only"!==this.walletChainType,r=this.externalWalletConfig.solana.connectors?.get()||[],a=async e=>{if(!n)return;let t=e.find(e=>"walletconnect_solana"===e.walletBranding?.id);t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};a(r),r.filter(e=>n||"walletconnect_solana"!==e.walletBranding?.id).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.(e=>{a(e),e?.filter(e=>n||"walletconnect_solana"!==e.walletBranding?.id).forEach(this.addSolanaWalletConnector)}),await t,this.initialized=!0}findWalletConnector(e,t,n){return"wallet_connect_v2"===e?this.walletConnectors.filter(C.r).find(t=>t.connectorType===e&&(!n||t.wallets.some(e=>e.address===n)))??null:this.walletConnectors.filter(C.r).find(r=>r.connectorType===e&&r.walletClientType===t&&(!n||r.wallets.some(e=>e.address===n)))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(C.v).find(t=>"unknown"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e)??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter(e=>"embedded"===e.connectorType)}findImportedWalletConnectors(){return this.walletConnectors.filter(e=>"embedded_imported"===e.connectorType)}onInitialized(e){e.wallets.forEach(e=>{let t=this.storedConnections.find(t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)}),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&this.emit("walletsUpdated")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:n,defaultChain:r,appId:a,privyClient:i}){let{entropyId:s,entropyIdVerifier:o}=(0,_.g)(t);for(let t of n){let n=this.findEmbeddedWalletConnectors().find(e=>e.walletIndex===t.walletIndex);if(n&&(0,C.r)(n))n.proxyProvider.walletProxy=e;else{let n=new ei({provider:new tG({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id,walletIndex:t.walletIndex,privyClient:i,walletAccount:t}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(n)}}}addImportedWalletConnector(e,t,n,r){let a=this.findWalletConnector("embedded_imported","privy",t);if(a&&(0,C.r)(a))a.proxyProvider.walletProxy=e;else{let a=new ei({provider:new tG({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:n.id}),chains:this.chains,walletIndex:0,defaultChain:n,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(a)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter(e=>"embedded"!==e.connectorType),this.storedConnections=(0,T.l)(),this.emit("walletsUpdated")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach(e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)}),this.storedConnections=(0,T.l)(),this.emit("walletsUpdated"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:n,walletConfig:r}){let a=this.findWalletConnector(e,t);if(a&&(0,C.r)(a))return a instanceof e7&&a.resetConnection(t),a;let i="injected"!==e?"coinbase_wallet"===e?new er(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):"base_account"===e?new et(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):"null"!==e?new e7({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):r?new C.w({id:r.client,name:r.name,defaultChain:this.defaultChain,walletClientType:r.client}):null:"metamask"===t&&n?.eip6963InjectedProvider?new t2(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,"metamask"):"metamask"===t&&n?.legacyInjectedProvider?new t1(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"metamask"):"phantom"===t&&n?.legacyInjectedProvider?new t1(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"phantom"):n?.legacyInjectedProvider&&"unknown_browser_extension"===t?new t1(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider):n?.eip6963InjectedProvider?new tX(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,t):void 0;return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",()=>this.onInitialized(e)),e.on("walletsUpdated",()=>this.onWalletsUpdated(e)),e.initialize().catch(e=>{console.debug("Failed to initialize connector",e)})}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,n,r,a,i,s,o,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||"null"===t.connectorType){if("null"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=n,this.chains=r,this.defaultChain=a,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=u||"ethereum-only",this.setBaseAccountSdk=d,this.storedConnections=(0,T.l)()}}let t5=(0,j.v)(()=>({identityToken:null})),t3=[R.z,R.A,R.B];class t6{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw(0,k.f)(e)}}async post(e,t,n){try{return await this.baseFetch(e,{method:"POST",...t?{body:t}:{},...n})}catch(e){throw(0,k.f)(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:"DELETE",...t})}catch(e){throw(0,k.f)(e)}}constructor({appId:e,appClientId:t,client:n,defaults:r}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=n.clientAnalyticsId,this.sdkVersion=I.V,this.client=n,this.defaults=r,this.fallbackApiUrl=n.fallbackApiUrl,this.baseFetch=G.OT.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:"include",onRequest:async({request:e,options:t})=>{let n=new Headers(t.headers);n.set("privy-app-id",this.appId),this.appClientId&&n.set("privy-client-id",this.appClientId),n.set("privy-ca-id",this.clientAnalyticsId||""),n.set("privy-client",`react-auth:${this.sdkVersion}`);let r=t3.includes(e.toString());if(!n.has("authorization")){let e=await this.client.getAccessToken({disableAutoRefresh:r});null!==e&&n.set("authorization",`Bearer ${e}`)}t.headers=n,t.retryDelay&&"number"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&"AbortError"===e.name)throw new k.h}})}}class t7{getOrCreateGuestCredential(e){let t=(0,I.g)(e);if((0,T.b)()){if(T.s.get(t))return T.s.get(t);{let e=v.l(eg(32));return T.s.put(t,e),e}}return v.l(eg(32))}async authenticate(){if(!this.api)throw new k.a("Auth flow has no API instance");try{return await this.api.post(R.C,{guest_credential:this.meta.guestCredential})}catch(e){throw(0,k.f)(e)}}async link(){throw Error("Linking is not supported for the guest flow")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function t8(){return!(W.nr&&window.location.origin.startsWith("http://localhost"))}var t9,ne,nt=((ne={}).PRIVY="privy_access_token",ne.CUSTOMER="customer_access_token",ne);class nn{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(I.C)}get privyAccessToken(){return this._getToken(I.P)}_getToken(e){try{let t=T.s.get(e);return"string"==typeof t?J.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=T.s.get(I.R);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=T.s.get((0,I.e)(e));if("string"!=typeof t)return null;{let n=new J(t);return n.isExpired()?(T.s.del((0,I.e)(e)),null):n.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=Y.A.get(I.f);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),n="string"==typeof this.refreshToken&&this.refreshToken!==I.h;return this.mightHaveServerCookies||t&&n}hasActiveAccessToken(e){let t=J.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?T.s.put((0,I.e)(e),t):T.s.del((0,I.e)(e))}updateIdentityToken(e){"string"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:n,is_new_user:r,oauth_tokens:a}=t;this.handleTokenResponse(t);let i=a?{provider:a.provider,accessToken:a.access_token,accessTokenExpiresInSeconds:a.access_token_expires_in_seconds,refreshToken:a.refresh_token,refreshTokenExpiresInSeconds:a.refresh_token_expires_in_seconds,scopes:a.scopes}:void 0;return this._trackAuthenticateEvents(e,r),{user:(0,A.l)(n),isNewUser:r,oAuthTokens:i}}catch(e){throw console.warn("Error authenticating session"),(0,k.i)(e)}}_trackAuthenticateEvents(e,t){let n=e instanceof ec?"email":e instanceof eS?"sms":e instanceof eT?"siwe":e instanceof t7?"guest":e instanceof tF?"custom_auth":e instanceof eb?e.meta.provider:null;n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:n,isNewUser:t}}),"siwe"===n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),n=t.oauth_tokens,r=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return{user:(0,A.l)(t),oAuthTokens:r}}catch(e){throw console.warn("Error linking account"),(0,k.i)(e)}}async _refresh(){if(!this.api)throw new k.a("Session has no API instance");if(!this.client)throw new k.a("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let n;if(!(e&&t||this.mightHaveServerCookies))return null;{let r={};e&&(r.authorization=`Bearer ${e}`),n=await this.api.post(R.z,t?{refresh_token:t}:{},{headers:r})}return this.handleTokenResponse(n),(0,A.l)(n.user)}catch(e){if(e instanceof k.e&&e.privyErrorCode===k.b.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw(0,k.i)(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await this.api?.post(R.A,{refresh_token:this.refreshToken})}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if("string"==typeof e){let t=T.s.get(I.C);if(T.s.put(I.C,e),!this.client?.useServerCookies){let t=J.parse(e)?.expiration;Y.A.set(I.i,e,{sameSite:"Strict",secure:t8(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else T.s.del(I.C),Y.A.remove(I.i),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){"string"==typeof e?(T.s.put(I.R,e),this.client?.useServerCookies||Y.A.set(I.f,"t",{sameSite:"Strict",secure:t8(),expires:30})):(T.s.del(I.R),Y.A.remove(I.j),Y.A.remove(I.f))}storePrivyAccessToken(e){"string"==typeof e?T.s.put(I.P,e):T.s.del(I.P)}storeIdentityToken(e){if(t5.setState({identityToken:e}),this.client?.useServerCookies)return;T.s.put(I.I,e);let t=J.parse(e)?.expiration;Y.A.set(I.k,e,{sameSite:"Strict",secure:t8(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){T.s.del(I.I),t5.setState({identityToken:null}),Y.A.remove(I.k)}constructor(){this.authenticateOnce=new eu(async e=>this._authenticate(e)),this.linkOnce=new eu(async e=>this._link(e)),this.refreshOnce=new eu(this._refresh.bind(this)),this.destroyOnce=new eu(this._destroy.bind(this))}}var nr=0,na="__private_"+nr+++"__getOrGenerateClientAnalyticsId";class ni{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,store:a,walletList:i,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new t4(this.appId,e,t,n,r,a,i,s,o,l,d,c))}generateApi(){let e=new t6({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new k.a("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new k.a("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter(e=>"cross_app"===e.type).forEach(e=>{this.storeProviderAccessToken(e.providerApp.id,null)})}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(R.D,{action:"verify"})}catch(e){throw(0,k.f)(e)}}async initMfaPasskeyVerification(){try{let e,t=await this.api.post(R.E,{});return{rpId:(e=t.options).rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map(e=>({id:e.id,type:e.type,transports:e.transports}))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}catch(e){throw(0,k.f)(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(R.F,{});return(0,A.l)(e)}catch(e){throw(0,k.i)(e)}}async unlinkEmail(e){try{let t=await this.api.post(R.G,{address:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async unlinkPhone(e){try{let t=await this.api.post(R.H,{phoneNumber:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(R.I,{address:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(R.J,{address:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async unlinkOAuth(e,t){try{let n=await this.api.post(R.K,{provider:e,subject:t});return await this.getAuthenticatedUser()??(0,A.l)(n)}catch(e){throw(0,k.i)(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(R.L,{fid:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async unlinkTelegram(e){try{let t=await this.api.post(R.M,{telegram_user_id:e});return await this.getAuthenticatedUser()??(0,A.l)(t)}catch(e){throw(0,k.i)(e)}}async revokeDelegatedWallet(){try{await this.api.post(R.N,{})}catch(e){throw(0,k.i)(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:n,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(R.B,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:n?n.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){console.log("Unable to submit event. This is not an issue.")}}async signMoonpayOnRampUrl(e){try{return this.api.post(R.O,e)}catch(e){throw(0,k.i)(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(R.P,e)}catch(e){throw(0,k.i)(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${R.Q}?partnerUserId=${e}`)}catch(e){throw(0,k.i)(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(nt.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(nt.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?Q.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(n){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(R.R,{address:e,token:t})).nonce}catch(e){throw(0,k.i)(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i}){return await this.api.post(R.S,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){return await this.api.post(R.T,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a})}async linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:r}){try{let a=await this.api.post(R.U,{message:e,signature:t,smart_wallet_type:n,smart_wallet_version:r});return(0,A.l)(a)}catch(e){throw(0,k.i)(e)}}async linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a});return(0,A.l)(i)}catch(e){throw(0,k.i)(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(R.V,{address:e,token:t})).nonce}catch(e){throw(0,k.i)(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){return await this.api.post(R.W,{message:e,signature:t,walletClientType:n,connectorType:r,mode:a,message_type:i})}async authenticateWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){let s=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i});this.session.handleTokenResponse(s);let o=(0,A.l)(s.user);if(!o)throw Error("Authentication failed - no user returned");return{user:o,isNewUser:s.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:r,telegramAuthResult:a,telegramWebAppData:i,farcasterEmbeddedAddress:s,oAuthUserInfo:o}){try{let l,c;switch(n){case"email":l=R.a1,c={nonce:e,email:t};break;case"sms":l=R.a0,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=R.$,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=R._,c={nonce:e,farcaster_id:t,farcaster_embedded_address:s};break;case"telegram":l=R.Z,c={nonce:e,telegram_auth_result:a,telegram_web_app_data:i};break;case"siws":l=R.Y,c={nonce:e,address:t,...r};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=R.X,c={nonce:e,userInfo:o}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??(0,A.l)(d)}catch(e){throw(0,k.i)(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){return await this.api.post(R.a2,{message:e,signature:t,walletClientType:n,connectorType:r,message_type:a})}async linkWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){try{let i=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a});return(0,A.l)(i)}catch(e){throw(0,k.i)(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(R.a3);return this.session.updateIdentityToken(e.identity_token),(0,A.l)(e.user)}catch(e){throw(0,k.i)(e)}}async scanTransaction(e){try{return await this.api.post(R.a4,e)}catch(e){throw(0,k.i)(e)}}constructor({apiUrl:e=I.D,appId:t,appClientId:n,timeout:r=I.l}){Object.defineProperty(this,na,{value:ns}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==I.D&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=n,this.clientAnalyticsId=(function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e})(this,na)[na](),d||(d=new nn),this.session=d,this.api=this.generateApi(),this.session.client=this}}function ns(){if("undefined"==typeof window)return null;try{let e=T.s.get(I.d);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=(0,g.A)();try{return T.s.put(I.d,e),e}catch(t){return e}}function no(){if(!u)throw new k.a("No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.");return u}let nl=({config:e,...t})=>{(()=>{if((0,p.useContext)(tV))throw new k.a("Multiple PrivyProvider instances found","Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")})(),function(){if("undefined"==typeof window)return;let e=["localhost","127.0.0.1"].includes(window.location.hostname),t="https:"===window.location.protocol||"chrome-extension:"===window.location.protocol;if(!e&&!t)throw new k.a("Embedded wallet is only available over HTTPS")}(),function(e){if("string"!=typeof e||25!==e.length)throw new k.a("Cannot initialize the Privy provider with an invalid Privy app ID")}(t.appId),u||(u=new ni({appId:t.appId,appClientId:t.clientId,apiUrl:t.apiUrl}));let n=(0,p.useMemo)(()=>new y.A({appId:t.appId,clientId:t.clientId,storage:T.s,baseUrl:t.apiUrl,sdkVersion:"react-auth:3.13.1"}),[]),r=no(),a=Object.assign({},e);return(0,h.jsx)(I.m,{client:n,legacyClient:r,appClientId:t.clientId,clientConfig:a,children:(0,h.jsx)(V.P,{configPlugins:e?.plugins,children:(0,h.jsx)(tK,{...t,client:r,privy:n})})})};function nc(){let{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:a}=(0,p.useContext)(A.P);return{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:a}}function nd(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:a,submitEnrollmentWithPasskey:i,unenroll:s,enrollInMfa:o}=(0,p.useContext)(A.P);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:a,submitEnrollmentWithPasskey:i,unenrollWithSms:()=>s("sms"),unenrollWithTotp:()=>s("totp"),unenrollWithPasskey:e=>s("passkey",e),showMfaEnrollmentModal:()=>o(!0),closeMfaEnrollmentModal:()=>o(!1)}}}}]);