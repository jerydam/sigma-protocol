"use strict";exports.id=5085,exports.ids=[5085],exports.modules={45085:(a,b,c)=>{function d(a){let b=new Uint8Array(a),c="";for(let a of b)c+=String.fromCharCode(a);return btoa(c).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function e(a){let b=a.replace(/-/g,"+").replace(/_/g,"/"),c=(4-b.length%4)%4,d=atob(b.padEnd(b.length+c,"=")),e=new ArrayBuffer(d.length),f=new Uint8Array(e);for(let a=0;a<d.length;a++)f[a]=d.charCodeAt(a);return e}function f(){return g.stubThis(globalThis?.PublicKeyCredential!==void 0&&"function"==typeof globalThis.PublicKeyCredential)}c.r(b),c.d(b,{WebAuthnAbortService:()=>l,WebAuthnError:()=>j,_browserSupportsWebAuthnAutofillInternals:()=>r,_browserSupportsWebAuthnInternals:()=>g,base64URLStringToBuffer:()=>e,browserSupportsWebAuthn:()=>f,browserSupportsWebAuthnAutofill:()=>q,bufferToBase64URLString:()=>d,platformAuthenticatorIsAvailable:()=>t,startAuthentication:()=>s,startRegistration:()=>o});let g={stubThis:a=>a};function h(a){let{id:b}=a;return{...a,id:e(b),transports:a.transports}}function i(a){return"localhost"===a||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(a)}class j extends Error{constructor({message:a,code:b,cause:c,name:d}){super(a,{cause:c}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=d??c.name,this.code=b}}class k{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){let a=Error("Cancelling existing WebAuthn API call for new one");a.name="AbortError",this.controller.abort(a)}let a=new AbortController;return this.controller=a,a.signal}cancelCeremony(){if(this.controller){let a=Error("Manually cancelling existing WebAuthn API call");a.name="AbortError",this.controller.abort(a),this.controller=void 0}}}let l=new k,m=["cross-platform","platform"];function n(a){if(a&&!(0>m.indexOf(a)))return a}async function o(a){let b,c,g,k,m;!a.optionsJSON&&a.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),a={optionsJSON:a});let{optionsJSON:o,useAutoRegister:q=!1}=a;if(!f())throw Error("WebAuthn is not supported in this browser");let r={...o,challenge:e(o.challenge),user:{...o.user,id:e(o.user.id)},excludeCredentials:o.excludeCredentials?.map(h)},s={};q&&(s.mediation="conditional"),s.publicKey=r,s.signal=l.createNewAbortSignal();try{b=await navigator.credentials.create(s)}catch(a){throw function({error:a,options:b}){let{publicKey:c}=b;if(!c)throw Error("options was missing required publicKey property");if("AbortError"===a.name){if(b.signal instanceof AbortSignal)return new j({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:a})}else if("ConstraintError"===a.name){if(c.authenticatorSelection?.requireResidentKey===!0)return new j({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:a});else if("conditional"===b.mediation&&c.authenticatorSelection?.userVerification==="required")return new j({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:a});else if(c.authenticatorSelection?.userVerification==="required")return new j({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:a})}else if("InvalidStateError"===a.name)return new j({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:a});else if("NotAllowedError"===a.name)return new j({message:a.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:a});else if("NotSupportedError"===a.name)return new j(0===c.pubKeyCredParams.filter(a=>"public-key"===a.type).length?{message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:a}:{message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:a});else if("SecurityError"===a.name){let b=globalThis.location.hostname;if(!i(b))return new j({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:a});if(c.rp.id!==b)return new j({message:`The RP ID "${c.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:a})}else if("TypeError"===a.name){if(c.user.id.byteLength<1||c.user.id.byteLength>64)return new j({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:a})}else if("UnknownError"===a.name)return new j({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:a});return a}({error:a,options:s})}if(!b)throw Error("Registration was not completed");let{id:t,rawId:u,response:v,type:w}=b;if("function"==typeof v.getTransports&&(g=v.getTransports()),"function"==typeof v.getPublicKeyAlgorithm)try{k=v.getPublicKeyAlgorithm()}catch(a){p("getPublicKeyAlgorithm()",a)}if("function"==typeof v.getPublicKey)try{let a=v.getPublicKey();null!==a&&(m=d(a))}catch(a){p("getPublicKey()",a)}if("function"==typeof v.getAuthenticatorData)try{c=d(v.getAuthenticatorData())}catch(a){p("getAuthenticatorData()",a)}return{id:t,rawId:d(u),response:{attestationObject:d(v.attestationObject),clientDataJSON:d(v.clientDataJSON),transports:g,publicKeyAlgorithm:k,publicKey:m,authenticatorData:c},type:w,clientExtensionResults:b.getClientExtensionResults(),authenticatorAttachment:n(b.authenticatorAttachment)}}function p(a,b){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${a}. You should report this error to them.
`,b)}function q(){if(!f())return r.stubThis(new Promise(a=>a(!1)));let a=globalThis.PublicKeyCredential;return a?.isConditionalMediationAvailable===void 0?r.stubThis(new Promise(a=>a(!1))):r.stubThis(a.isConditionalMediationAvailable())}let r={stubThis:a=>a};async function s(a){let b,c,g;!a.optionsJSON&&a.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),a={optionsJSON:a});let{optionsJSON:k,useBrowserAutofill:m=!1,verifyBrowserAutofillInput:o=!0}=a;if(!f())throw Error("WebAuthn is not supported in this browser");k.allowCredentials?.length!==0&&(b=k.allowCredentials?.map(h));let p={...k,challenge:e(k.challenge),allowCredentials:b},r={};if(m){if(!await q())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&o)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');r.mediation="conditional",p.allowCredentials=[]}r.publicKey=p,r.signal=l.createNewAbortSignal();try{c=await navigator.credentials.get(r)}catch(a){throw function({error:a,options:b}){let{publicKey:c}=b;if(!c)throw Error("options was missing required publicKey property");if("AbortError"===a.name){if(b.signal instanceof AbortSignal)return new j({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:a})}else if("NotAllowedError"===a.name)return new j({message:a.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:a});else if("SecurityError"===a.name){let b=globalThis.location.hostname;if(!i(b))return new j({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:a});if(c.rpId!==b)return new j({message:`The RP ID "${c.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:a})}else if("UnknownError"===a.name)return new j({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:a});return a}({error:a,options:r})}if(!c)throw Error("Authentication was not completed");let{id:s,rawId:t,response:u,type:v}=c;return u.userHandle&&(g=d(u.userHandle)),{id:s,rawId:d(t),response:{authenticatorData:d(u.authenticatorData),clientDataJSON:d(u.clientDataJSON),signature:d(u.signature),userHandle:g},type:v,clientExtensionResults:c.getClientExtensionResults(),authenticatorAttachment:n(c.authenticatorAttachment)}}function t(){return f()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(a=>a(!1))}}};